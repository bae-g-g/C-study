# Int Negative Number

# **int 음수 입력/저장**
메모리박스 2진수 입력/저장 처리
int 자료형은 4 Bytes = 32 Bits 지만, 下 내용은 편의를 위해 가장 뒤 4 Bits만 추출하여 설명

## **int 음수 입력/저장** **처리방식 1****: sign**

*   자료형 형태: int 변수 \* int A; int B; int C;
*   자료형 크기: 4 Bytes = 32 Bits
*   자료형 범위: -2^31 ~ 2^31\-1
\* \-1:
. 1 Bit: 입력/저장 가능 숫자 갯수 ➝ 2진수 2개 (0 or 1)
. 32 Bits: 2^32개 숫자 입력/저장
. 2^31: 32 Bit 자리수 초과하므로 범위는 \-1

E.g)
4 Bits
![](https://t9003081320.p.clickup-attachments.com/t9003081320/7caac1a6-d2ed-4e32-9cab-bfc8c2099d2a/Picture1.png)

*   가장 처음 1 Bit: 양수/음수 처리
0 = 양수
1 = 음수
*   나머지 3 Bits: 숫자 처리
*   E.g)

**1**001 = **\-**(2^0\*1) = **-**1, **1**011 = **-**(2^1\*1 + 2^0\*1) = **\-**3

* * *

*   문제점 1
**1**000 = 0 ←→ **0**000 = 0 \* 0은 양수/음수 없음
두 2진수 모두 0 ?!?!? Confused

*   문제점 2
연산 처리 복잡
양수 + 양수 = Fine
E.g)
**0**001 + **0**101 = **0**110
1 + 5 = 6
양수 + 음수 = Complex
E.g)
**0**001 + **1**001 = **1**010
1 + (-1) = -2 ?!?!?

## int 음수(2진수) 입력/저장 처리방식 2: 2의 보수

*   문제점 해결방법 ➝ [Two's Complement](https://app.clickup.com/9003081320/v/dc/8ca07k8-22/8ca07k8-4258)
컴퓨터는 연산을 위해 음수는 2의 보수로 '초기화'(입력/저장) 처리

Step 1: 10진수 ➝ 2진수
Step 2: 2진수 Not 연산 (0 ➝ 1, 1 ➝ 0)
Step 3: + 1

* * *

*   E.g)

10진수 7의 음수 입력/저장

Step 1: 7의 2진수: 7 = 0111 \* 2^2\*1 + 2^1\*1 + 2^0\*1 = 4 + 2 + 1 = 7
Step 2: 7의 2진수 Not 연산: 0111 ➝ 1000
Step 3: 1000 + 1 = 1001

∴ 10진수 7(2진수 0111)의 음수
\= 10진수 -7
\= 2진수 1001

※ 처리방식 1: sign 입력/저장 처리방식 X
\= \- 2^2\*0 + ..... + 2^0\*1
\= - 1
1001 = 2^2\*0 +..... + 2^0\*1 = -1이 아니라, 2의 보수 처리하여 (-7)로 입력/저장 처리

※ 일반 2진수➝10진수 처리방식 X
\= 2^3\*1 + ..... + 2^0\*1
\= 9
1001 = 2^3\*1 + ..... + 2^0\*1 = 9가 아니라, 2의 보수 처리하여 (-7)로 입력/저장 처리

* * *

*   E.g)

10진수 6의 음수 입력/저장

Step 1: 6의 2진수: 6 = 0110 \* 2^2\*1 + 2^1\*1 = 4 + 2 = 6
Step 2: 6의 2진수 Not 연산: 0110 ➝ 1001
Step 3: 1001 + 1 = 1010

∴ 10진수 6(2진수 0110)의 음수
\= 10진수 -6
\= 2진수 1010

※ 처리방식 1: sign 입력/저장 처리방식 X
\= \- 2^2\*0 + 2^1\*1 + 2^0\*1
\= - 3
1010 = 2^2\*0 + 2^1\*1 + 2^0\*1 = -3가 아니라,
2의 보수 처리하여 (-6)로 입력/저장 처리

※ 일반 2진수➝10진수 처리방식 X
\= 2^3\*1 + 2^2\*0 + 2^1\*1 + 2^0\*0
\= 10
1010 = 2^3\*1 + 2^2\*0 + 2^1\*1 + 2^0\*0 = 10이 아니라,
2의 보수 처리하여 (-7)로 입력/저장 처리

* * *

※ `가정` 4 Bits에서 2의 보수에 의한 2진수 양수/음수

![](https://t9003081320.p.clickup-attachments.com/t9003081320/54791917-a23e-4cac-9126-c2907a855984/int_minus_promise_2.png)

E.g)
\-3 + 2 = -1 ➝ 1101 + 0010 = 1111

* * *

※ `실제` 32 Bits에서 2의 보수에 의한 2진수 양수/음수

![](https://t9003081320.p.clickup-attachments.com/t9003081320/613367d3-6ca2-44d6-8bee-7962b3470f33/Picture1.png)

*   10진수 7 = X = 00000000 00000000 00000000 000000111
*   10진수 - 7 = \- X = 11111111 11111111 11111111 111111001
\* 처리방식 1: sign 입력/저장 처리방식 X
\= \- 2^30\*1 + ..... + 2^0\*1
**≠ -7**
\* 일반 2진수➝10진수 처리방식 X
\= - 2^31\*1 + ..... + 2^0\*1
**≠ -7**

## **int 양수(2진수) 입력/저장** **처리방식 3****: unsigned**

*   자료형 형태: unsigned int 변수 \* unsigned int A, unsigned int B, unsigned int C
*   자료형 크기: 4 Bytes = 32 Bits
*   자료형 범위: 0 ~ 2^32-1

*   처리방식 1 & 처리방식 2와 달리 가장 처음 Bit 양수(+)/음수(-) 구분 없이 양수(+)로 입력/저장
*   E.g)

2진수 1001 = (2^3)\*1 + (2^0)\*1 = 9

*   적용: 음수(-)가 없는 변수 사용시

➝ 성적, 사람수, 심장박동수 등

* * *

**a\_notation\_1.c**

다양한 진법 '초기화'(입력/저장) 형식

int A = 0b11; // 2진법 형식: 0b
int B = 011; // 8진법 형식: 0
int C = 0x11; // 16진법 형식: 0x
int D = 11; // 10진법 형식:

![](https://t9003081320.p.clickup-attachments.com/t9003081320/40348434-5e54-4f04-94fb-07a6839f590f/Picture10.png)

```cpp
// 다양한 진법 '초기화'(입력/저장) 형식

#include <stdio.h>

int main()
{
    int A = 0b11; // 0b는  2진법 '초기화'(입력/저장) 지정형식:  2진법 ➝  2진법 11 =  (2^1)*1 +  (2^0)*1 = 3
    int B = 011;  //  0는  8진법 '초기화'(입력/저장) 지정형식:  8진법 ➝  8진법 11 =  (8^1)*1 +  (8^0)*1 = 9
    int C = 0x11; // 0x는 16진법 '초기화'(입력/저장) 지정형식: 16진법 ➝ 16진법 11 = (16^1)*1 + (16^0)*1 = 17
    int D = 11;   //   는 10진법 '초기화'(입력/저장) 지정형식: 10진법 ➝ 10진법 11 = (10^1)*1 + (10^0)*1 = 11
    
    // 자리수 맞춰 출력위해 출력형식("  ") 내 띄어쓰기 고려
    printf(" 2진법 11 10진수 값: %d\n", A);
    // 2진법 11 2진수 값:  2진수 값 출력서식 없음 ➝ for 반복문 코드로 출력가능
    printf("-----------------------\n"); 
    printf(" 8진법 11 10진수     값: %d\n", B);
    printf(" 8진법 11  8진수     값: %o\n", B);  // 8진수 값 출력서식: %o
    printf(" 8진법 11  8진수 형식값: %#o\n", B); // 8진수 형식값 출력서식: %#o
    printf("-----------------------\n"); 
    printf("16진법 11 10진수     값: %d\n", C);
    printf("16진법 11 16진수     값: %x\n", C);  // 16진수 값 출력서식: %x ➝ 소문자,  %X ➝ 대문자
    printf("16진법 11 16진수 형식값: %#x\n", C); // 16진수 형식값 출력서식: %#x ➝ 소문자,  %#X ➝ 대문자
    printf("-----------------------\n"); 
    printf("10진법 11 10진수 값: %d\n", D);
    
    printf("-----------------------\n"); 
    printf("-----------------------\n");  

    printf(" 2진법 11 주소값: %d\n", &A);
    printf(" 8진법 11 주소값: %d\n", &B);
    printf("16진법 11 주소값: %d\n", &C);
    printf("10진법 11 주소값: %d\n", &D);
    
    return 0;
}


```

**a\_notation\_2.c**

다양한 진법 '형식' 출력

int A = 11;
int A = 80;

```cpp
// 다양한 진법 '형식값' 출력 

#include <stdio.h>

// Case 1
int main()
{
    int A = 11; 

    printf("%d\n", A);  // 10진법:  11 
    // 2진법 출력서식 없음 ➝ 반복문 코드로 출력가능
    printf("%#o\n", A); //  8진법:  13 = (8^1)*1 + (8^0)*3 = 10진법 11 = ASCII Code 013 
    printf("%#x\n", A); // 16진법:   B = ASCII Code 0xB   
    
    return 0;
}

// Case 2
int main()
{
    int A = 80; 

    printf("%d\n", A);  // 10진법:  80 
    // 2진법 출력서식 없음 ➝ 반복문 코드로 출력가능
    printf("%#o\n", A); //  8진법:  120 = (8^2)*1 + (8^1)*2 = 10진법 80 = ASCII Code 0120 
    printf("%#x\n", A); // 16진법:   50 = (16^1)*5 = 10진법 80 = ASCII Code 0x50   
    
    return 0;
}


```

**a\_notation\_3.c**

다양한 진법 '값' 출력

int A = 11;
int A = 80;

```cpp
// 다양한 진법 '값' 출력

#include <stdio.h>

// Case 1
int main()
{
    int A = 11; 

    printf("%d\n", A);  // 10진법:  11 
    // 2진법 출력서식 없음 ➝ 반복문 코드로 출력가능
    printf("%o\n", A); //  8진법:  13 = (8^1)*1 + (8^0)*3 = 10진법 11 = ASCII Code 013 
    printf("%x\n", A); // 16진법:   B = ASCII Code 0xB   
    
    return 0;
}

// Case 2
int main()
{
    int A = 80; 

    printf("%d\n", A);  // 10진법:  80 
    // 2진법 출력서식 없음 ➝ 반복문 코드로 출력가능
    printf("%o\n", A); //  8진법:  120 = (8^2)*1 + (8^1)*2 = 10진법 80 = ASCII Code 0120 
    printf("%x\n", A); // 16진법:   50 = (16^1)*5 = 10진법 80 = ASCII Code 0x50   
    
    return 0;
}


```

**※ 정수 10진수, 8진수, 16진수 출력**
[Reference](https://ehpub.co.kr/demimal-octal-hexadecimal-number-printf-c-language/)

**b\_complement.c**

2의 보수 '초기화'(입력/저장)

int X = 0b11111111111111111111111111111111; // 32 Bits 2진수 최대값
int Y = 0b00000000000000000000000000000001; // 32 Bits 2진수 최소값 + 1
int A = -1;
int B = 1;

int X = 0b101
int Y = 0b011;
int A = 5;
int B = 3;

➝ 10진수로 '초기화'(입력/저장) 하면 어떻게 2의 보수로 입력/저장 처리하는지 확인 어려움

```cpp
#include <stdio.h>

// Case 1
int main()
{
    int X = 0b11111111111111111111111111111111; // 32 Bits 2진수 최대값
                                                // 가장 처음 수 1 ➝ 음수 처리방식: [처리방식2] 2의 보수 입력/저장 처리방식 (Image 참조 = -1)
                                                // [처리방식1] sign 입력/저장 처리방식 X ➝ 2^31자리 1: 음수 표시 나머지 (2^30*1) + ..... (2^0)*1 = 4294967295 ➝ X
    int Y = 0b00000000000000000000000000000001; // 32 Bits 2진수 최소값 + 1
                                                // 가장 처음 수 0 ➝ 양수 처리방식: [처리방식1] sign 입력/저장 처리방식 (2^0*1 = 1)
    int A = -1;
    int B = 1;

    printf("X: %d\n", X);  
    printf("Y:  %d\n", Y);
    printf("X: %d\n", A);  
    printf("Y:  %d\n", B);

    printf("-----------------------\n");

    printf("더한 값:  %d\n", X + Y);
    printf("뺀   값: %d\n", X - Y);
    printf("더한 값:  %d\n", A + B);
    printf("뺀   값: %d\n", A - B);

    return 0;
}


// Case 2
int main()
{
    int X = 0b101; // int 자료형크기(32 Bits): 00000000000000000000000000000101 
                   // 가장 처음 수 0 ➝ 양수 처리방식: [처리방식1] sign 입력/저장 처리방식 (2^2*1) + (2^0*1) = 5
    int Y = 0b011; // int 자료형크기(32 Bits): 00000000000000000000000000000011
                   // 가장 처음 수 0 ➝ 양수 처리방식: [처리방식1] sign 입력/저장 처리방식 (2^1*1) + (2^0*1) = 3
    int A = 5;
    int B = 3;

    printf("X: %d\n", X);  
    printf("Y: %d\n", Y);
    printf("X: %d\n", A);  
    printf("Y: %d\n", B);

    printf("-----------------------\n");

    printf("더한 값: %d\n", X + Y);
    printf("뺀   값: %d\n", X - Y);
    printf("더한 값: %d\n", A + B);
    printf("뺀   값: %d\n", A - B);

    return 0;
}


```

**Case 1**

![](https://t9003081320.p.clickup-attachments.com/t9003081320/34c00f8b-b391-4b19-a0d0-41f702d1876e/Picture1.png)

![](https://t9003081320.p.clickup-attachments.com/t9003081320/d2da1c08-6732-4478-ac31-3177c8774f19/Picture2.png)

![](https://t9003081320.p.clickup-attachments.com/t9003081320/d7bd7c43-b65b-4d31-9594-28586d896b89/Picture3.png)

**c\_sign\_unsinged.c**

sign & unsigned 구분

unsigned int X = 0b11111111111111111111111111111111; // 32 Bits 2진수 최대값
int Y = 0b11111111111111111111111111111111; // 32 Bits 2진수 최대값

unsigned int X = 0b101;
    int Y = 0b101;

➝ 10진수로 '초기화'(입력/저장) 하면 How 2의 보수로 입력/저장 처리 확인 어려움

```cpp
#include <stdio.h>

// Case 1
int main()
{
    unsigned int X = 0b11111111111111111111111111111111; // 음수/양수 구분 하지 X: [처리방식3] unsigned 입력/저장 처리방식
                                                         // (2^31*1) + ... (2^0*1) =  4294967295
    int Y = 0b11111111111111111111111111111111; // 가장 처음 수 1 ➝ 음수 처리방법: [처리방식2] 2의 보수 입력/저장 처리방식 (Image 참조 = -1)
    
    printf("%%d로     sign X 출력: %d\n", X); // %d ➝ 음수 처리방식: [처리방식2] 2의 보수 입력/저장 처리방식 
    printf("%%u로 unsigned X 출력: %u\n", X); // %u ➝ 음수/양수 구분 X: [처리방식3] unsigned 입력/저장 처리방식 

    printf("--------------------------------\n");

    printf("%%d로     sign Y 출력: %d\n", Y); // %d ➝ 음수 처리방식: [처리방식2] 2의 보수 입력/저장 처리방식 
    printf("%%u로 unsigned Y 출력: %u\n", Y); // %u ➝ 음수/양수 구분 X: [처리방법3] unsigned 입력/저장 처리방식 
    
    return 0;
}

// Case 2
int main()
{
    unsigned int X = 0b101; // int 자료형크기(32 Bits): 00000000000000000000000000000101 
                            // 가장 처음 수 0 ➝ 양수 처리방식: [처리방식1] sign 입력/저장 처리방식 (2^2*1) + (2^0*1) = 5 
    int Y = 0b011; // int 자료형크기(32 Bits): 00000000000000000000000000000011
                   // 가장 처음 수 0 ➝ 양수 처리방식: [처리방식1] sign 입력/저장 처리방식 (2^1*1) + (2^0*1) = 3

    printf("%%d로     sign X 출력: %d\n", X); // %d ➝ 양수 처리방식: [처리방법1] sign 입력/저장 처리방식 
    printf("%%u로 unsigned X 출력: %u\n", X); // %u ➝ 음수/양수 구분 X: [처리방식3] unsigned 입력/저장 처리방식

    printf("--------------------------------\n");

    printf("%%d로     sign Y 출력: %d\n", Y); // %d ➝ 양수 처리방식: [처리방식1] sign 입력/저장 처리방식 
    printf("%%u로 unsigned Y 출력: %u\n", Y); // %u ➝ 음수/양수 구분 X: [처리방식3] unsigned 입력/저장 처리방식

    return 0;
}


```

*   sign, unsigned '선언': X

sign, unsigned 출력서식(%d, %u): O

*   sign, unsigned '선언': 컴퓨터는 구분: X

**Case 1**

![](https://t9003081320.p.clickup-attachments.com/t9003081320/34c00f8b-b391-4b19-a0d0-41f702d1876e/Picture1.png)

![](https://t9003081320.p.clickup-attachments.com/t9003081320/d2da1c08-6732-4478-ac31-3177c8774f19/Picture2.png)

![](https://t9003081320.p.clickup-attachments.com/t9003081320/d7bd7c43-b65b-4d31-9594-28586d896b89/Picture3.png)
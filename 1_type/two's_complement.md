# Two's Complement

## 보수 \*\*\*

\* 음수가 포함된 연산의 오류를 막기위한 컴퓨터 입력/저장 처리방식

\* X + `(-X)` = 0 개념 적용
더해서 0이 되는 두수 X & -X
X 의 보수값을 구하여 X의 **음수값으로 처리**하여 `-X` 값을 구함

\* 자료형의 크기(Bit) & 변수의 진수 표기에 따라 입력/저장 처리방식 다름

*   1 Bit 10진수:

3(=X)에 대한 1 Bit 10의 보수 \* 1Bit 10진수 ➝ 일반적인 수의 개념

3 + (-X) = 10

10 - 3 = 10^1 - 3 = `7(=-X)`
\* 10 = 10^1: 3이 가지는 자리수 보다 1자리수 큰자리수(2자리수)의 수중 가장 작은수

3 + 7 = 1**0** ➝ 1 Bit는 1자리수만 입력/저장 ➝ 0 입력/저장 O, 1 입력/저장 X

∴ 3 + 7 = 0 ➝ X + (-X) = 0 ➝ 더해서 0이 되는 두수 3 & 7

∴ `7(=-X)`은 3(=X)에 대한 1 Bit 10의 보수

∴ `7(=-X)`을 3(=X)의 1 Bit 10진수 보수로 입력/저장 처리

*   4 Bits 2진수:

0111(10진수 7=X)에 대한 4 Bits 2의 보수

0111 + (-X) = 10000

10000 - 0111 = 2^4 - 0111 = `1001(=-X)`

\* 10000 = 2^4: 0111이 가지는 자리수 보다 1자리수 큰자리수(5자리수)의 수중 가장 작은수

0111 + 1001 = 1**0000** ➝ 4 Bits는 4자리수만 입력/저장 ➝ 0000 = 0 입력/저장 O, 1 입력/저장 X

∴ 0111 + 1001 = 0 ➝ X + (-X) = 0 ➝ 더해서 0이 되는 두수 0111 & 1001

∴ `1001(=-X)`은 0111(=X)에 대한 4 Bits 2진수 보수
∴ `1001(=-X)`을 0111(10진수 7=X)의 4 Bits 2진수 보수로 입력/저장 처리
1001 = 2^3\*1 + 2^0\*1 = 9 지만 -7로 입력/저장 처리

## _i_ Bit _j_진수의 보수
_i_ = 자료형의 크기
_j_ = 변수의 진수 표기

X의 보수 -X
➝ **`(`****_`j`_** **`^`** **_`i)`_** **`- X`** **\* 진수** **_j_** **^ 자료형의크기** **_i_** **\- 변수의** **_j_** **진수값**

*   1 Bit 10진수: 3(=X)에 대한 1 Bit 10의 보수 ➝ 10^1 - 3 = 7(=-X)
*   4 Bits 2진수: 0111(10진수 7=X)에 대한 4 Bits 2의 보수 ➝ 2^4 - 0111 = 10000 - 0111 = 1001(=-X)

* * *

## 4 Bits 2(진수)의 보수

_i_ = 자료형의 크기 = 4
_j_ = 변수의 진수 표기 = 2 ➝ 컴퓨터는 2진수(0 & 1)로 입력/저장

**Method 1: 보수**\*\*\* **개념 적용**

*   `변수가가지는 자리수 보다 1자리수 큰자리수의 수중 가장 작은수 - (변수의 2진수 값)`
\= `2^자료형의 크기(Bit) - (변수의 2진수 값)`

10000 - (X의 2진수) = -X
2^4 - (X의 2진수) = -X

**Method 2: Not 연산 개념 적용 (실제 컴퓨터 입력/저장 처리방식)**

*   Step 1: `자료형의 크기(Bit)에 입력/저장 가능 가장 큰 수 - (변수의 2진수 값)`
\= `Not 연산` (2진수: 0 ➝ 1, 1 ➝ 0)

4 Bits 2진수

예: 자료형의 크기(Bit)에 입력/저장 가능 가장 큰 수 - (변수의 2진수 값)
1111 - 0111 = 1000
예: Not 연산
0111 ➝ 1000

*   Step 2: `+ 1`

예: 1000 + 1 = 1001 \* **Method 1**의 결과값과 같음

※ **Method 2:** `Not 연산 + 1`
\= \[Method 1: 보수 개념\]을 바탕으로 컴퓨터가 처리하기위해 시스템화(패턴화)한 방식
컴퓨터가 가지고 있는 Bits 자체는 초과하여 확장 X (예: 4 Bits ➝ 5 Bits, 32 Bits ➝ 33 Bits)

* * *

※ **Method 1** & **Method 2**의 차이

*   Method 1: 먼저 1을 더하기 ➝ 2^4 = 10000 = 1111 + 1

컴퓨터가 가지고 있는 Bits 자체는 초과하여 확장 X (예: 4 Bits ➝ 5 Bits, 32 Bits ➝ 33 Bits)

∴ Method 1은 컴퓨터에서 실제 처리하는 방식 X

*   Method 2: 나중에 1을 더하기 ➝ 1111 + 1 = 10000

∴ `2^자료형의 크기(Bit)` = `자료형의 크기(Bit)에 입력/저장 가능 가장 큰 수` `+ 1`

4 Bits 2진수: 2^4 = 10000

![](https://t9003081320.p.clickup-attachments.com/t9003081320/31689bb2-d903-4717-9baf-d1250d905aef/Picture1.png)

Bits 입력/저장 가능 가장 큰 2진수 + 1 = 1111 + 1 = 10000

![](https://t9003081320.p.clickup-attachments.com/t9003081320/e288d2a0-9b16-481c-94a9-a6dec5236f8f/Picture2.png)

* * *

## 32 Bits 2의 보수 (int Data Type) \*\*\*

예: int X = 7; // 32 Bits

![](https://t9003081320.p.clickup-attachments.com/t9003081320/ab484cf3-7f0e-4e0c-a6bf-29bf959f9252/Picture1.png)

※ 11111111 11111111 1111111 11111001 을
10진수 7(=X)의 음수값인 -7(=-X)의 2진수값으로 입력/저장 처리
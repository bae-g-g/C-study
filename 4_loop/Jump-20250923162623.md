# Jump

## **Jump Statement 점프문**

E.g)
`Continue`
반복문 처음으로 회귀
E.g)
재입력 필요 상황 등

`Break`
반복문 종료
E.g)
Error 발생으로 프로그램 종료해야하는 상황 등

`Continue`
**h\_1\_continue\_1.c** (← **g\_condition\_loop\_2.c**)
E.g)
**g\_condition\_loop\_2.c**
숫자 입력 오류시(예: 음수) 반복 횟수 -1 O
**h\_1\_continue\_1.c**
while 문
Continue 실행 → 반복횟수증가 X (i++ 실행 X)

```awk
// while + if + continue
#include <stdio.h>

int main()
{
    int number[10];               // int number[10] = {0}; 초기화 필요 X
                                  // ∵ 음수입력시 23번째 continue로 인해 28번째줄 i++ 실행 X  → 양수 입력까지 같은 배열위치 초기화 대기 → 쓰레기값에 양수 덮어쓰기 초기화 O  

    printf("------Input-----\n");
    int i = 0;
    while (i < 10)
    {
        int input_number;
        printf("숫자를 입력하세요: ");
        scanf("%d", &input_number);
        if (input_number >= 0)
        {
            number[i] = input_number;
        }
        else
        {
            printf("잘못 입력했습니다.\n");
            continue;                        // 아래의 코드(i++)를 생략하고 반복문 처음으로 돌아옴 = i--
        }
        // continue;  // else문 실행시: 22번째 작성과 동일 기능 = 26번째줄 i++하기전 while문 처음 반복 실행
                      //  if 문 실행시: 26번째줄 i++ 실행 X
                      // ∴  24번째줄에 작성 X      
        i++;
    }

    printf("------Output-----\n");
    // for (int i = 0; i < 10; i++)   // for문 내에서 int i = 0을 선언 동시 초기화 (9번째 i ≠ 30번째줄 i)
    // {
    //     printf("%d번째: %d\n", i, number[i]);
    // }
    i = 0;           // 11번째줄~28번째줄 while문 반복종료시 i = 10
                     // 1) i 변수 그대로 사용하여 초기화 가능 O (i = 0)  &  i 변수 그대로 사용하여 선언 동시 초기화 가능 X (int i = 0) → Redefine Error(9번째줄)
                     // 2) 다른 변수명 사용 선언 동시 초기화(예: int j = 0, int k = 0)  가능 O 
                     // while문 조건식 or Code Block에서는 초기화 가능 X → while문 시작전 초기화 필요 O    ∵ while문 내 i = 0 초기화 → 반복할때마다 i = 0 → 무한 Loop 
    while (i < 10)
    {
        printf("%d번째: %d\n", i, number[i]);
        i++;
    }

    return 0;
}
```

**h\_1\_continue\_2.c** (← **g\_condition\_loop\_2.c**)
E.g)
**g\_condition\_loop\_2.c**
숫자 입력 오류시(예: 음수) 반복 횟수 -1 X
**h\_1\_continue\_2.c**
for 문
Continue 실행 → 반복횟수증가 O (i++ 실행 O)

```awk
// for + if + continue
#include <stdio.h>

int main()
{
    int number[10] = {0};    // int number[10] = {0}; 초기화 필요 O
                             // 1) 음수입력시 첫번째 for문(17번째줄)의 if문(21번째줄) 실행 X 
                             // 2) else문(25번째줄) 실행 O
                             // 3) 위의 내용 i < 10 까지 반복 
                             // 4) 여기(6번째줄) 선언시 남아있던 쓰레기값 두번째 for문(33번째줄)에서 출력가능 O
                             // ∴ \0=null 초기화 필요 O
                             
                             // ※ 28번째줄 i-- 작성해주면 음수입력시 횟수증가하지 않고 재입력 → 배열 0번째 ~ 9번째 초기화 가능
                             // ∴ \0=null 초기화 필요 X

    for (int i = 0; i < 10; i++)
    {
        int input_number;
        printf("%d번째 숫자를 입력하세요: ", i);
        scanf("%d", &input_number);
        if (input_number >= 0)
        {
            number[i] = input_number;
        }
        else
        {
            printf("잘못 입력했습니다.\n");
            // i--;                         // 횟수증가 X 
            continue;
        }
    }

    for (int i = 0; i < 10; i++)
    {
        printf("%d번째 : %d\n", i, number[i]);
    }
    return 0;
}


```

`Break`
**h\_2\_break\_1.c** (← **g\_condition\_loop\_2.c**)
E.g)
**g\_condition\_loop\_2.c**
숫자 입력 오류시 → 프로그램 종료
**h\_2\_break\_1.c**
while 문
Break 실행 → 반복문(while) 종료 → 프로그램 종료

```cpp
// for + if + break
#include <stdio.h>

int main()
{
    int number[10] = {0}; // int number[10] = {0}; 초기화 필요 O
                          // 1) 음수입력시 첫번째 for문(12번째줄)의 else문(20번째줄)의 break(23번째줄) 실행후 while문 종료
                          // 2) 나머지 배열의 요소들 초기화 X
                          // 3) 나머지 배열의 위치에 남아있던 쓰레기값들이 두번째 for문(27번째줄)에서 출력가능 O
                          // ∴  \0=null 초기화 필요 O
    for (int i = 0; i < 10; i++)
    {
        int input_number;
        printf("%d번째 숫자를 입력하세요: ", i);
        scanf("%d", &input_number);
        if (input_number >= 0)
        {
            number[i] = input_number;
        }
        else
        {
            printf("잘못 입력했습니다. 반복문을 종료합니다.\n");
            break;      // 반복문 탈출
        }
    }

    for (int i = 0; i < 10; i++)
    {
        printf("%d번째 : %d\n", i, number[i]);
    }
    return 0;
}
```

**h\_2\_break\_2.c** (← **g\_condition\_loop\_2.c**)
E.g)
**g\_condition\_loop\_2.c**
숫자 입력 오류시 → 프로그램 종료
**h\_2\_break\_2.c**
for 문
Break 실행 → 반복문(for) 종료 → 프로그램 종료

```cpp
// for + if + break
#include <stdio.h>

int main()
{
    int number[10];     // int number[10] = {0}; 초기화 필요 O
                        // 1) 음수입력시 첫번째 for문(12번째줄)의 else문(20번째줄)의 break(23번째줄) 실행후 while문 종료
                        // 2) 나머지 배열의 요소들 초기화 X
                        // 3) 나머지 배열의 위치에 남아있던 쓰레기값들이 두번째 for문(27번째줄)에서 출력가능 O
                        // ∴  \0=null 초기화 필요 O
    int input_number;
    for (int i = 0; i < 10; i++)
    {
        printf("%d번째 숫자를 입력하세요: ", i);
        scanf("%d", &input_number);
        if (input_number >= 0)
        {
            number[i] = input_number;
        }
        else
        {
            printf("잘못 입력했습니다. 반복문을 종료합니다.\n");
            break;      // 반복문 탈출
        }
    }

    for (int i = 0; i < 10; i++)
    {
        printf("%d번째 : %d\n", i, number[i]);
    }
    return 0;
}
```

`Continue` + `Break`
**h\_3\_continue\_break\_1.c**
E.g)
게임 캐릭터 움직임 방향 설정 오류 X → 프로그램 지속
게임 캐릭터 움직임 방향 설정 오류 O → 프로그램 종료
while + continue + break + scanf %c (for buffer)

```cpp
// while + if + continue + break + scanf %c (for buffer)
#include <stdio.h>

int main()
{
    char control_input;
    char buffer_box;

    while (1)            // (1) = 무한반복실행
    {
        scanf("%c", &control_input);
        scanf("%c", &buffer_box);
        if (control_input == 'w')
        {
            printf("Direction: GO\n");
            continue;
        }
        else if (control_input == 'a')
        {
            printf("Direction: LEFT\n");
            continue;
        }
        else if (control_input == 'd')
        {
            printf("Direction: RIGHT\n");
            continue;
        }
        else if (control_input == 's')
        {
            printf("Direction: STOP\n");
            continue;
        }
        else if (control_input == 'x')
        {
            printf("Direction: BACK\n");
            continue;
        }
        else if (control_input == 'q')
        {
            printf("Direction: Quit\n");
            break;       // 반복문 종료 = 프로그램 종료
        }
        else
        {
            printf("Error input: ");
            printf("%c \n", control_input);
            // break;       // 반복문 종료 = 프로그램 종료
        }
    }

    return 0;
}
```

**h\_3\_continue\_break\_2\_a\_getchar.c**
E.g)
게임 캐릭터 움직임 방향 설정 오류 X → 프로그램 지속
게임 캐릭터 움직임 방향 설정 오류 O → 프로그램 종료
while + continue + break + getchar (for buffer)

getchar();
버퍼의 첫번째 문자 읽고 비움

```awk
// while + if + continue + break + getchar (for buffer)
#include <stdio.h>

int main()
{
    char control_input; 
    while (1)        // 무한 실행
    {
        scanf("%c", &control_input);
        while(getchar() != '\n');    // = while(getchar() != '\n')
                                     //   {  
                                     //      Code Block;
                                     //   }
                                     // getchar():         버퍼의 첫번째 문자 읽고 비움
                                     // getchar() != '\n': 버퍼의 첫번째 문자가 엔터가 아닐때 까지 읽음
                                     // ∴ h_3_continue_break_1.c의 buffer_box 역할
                                     // 예:  wa엔터 입력/저장
                                     //      scanf("%c", &control_input);  wad\n 입력/저장
                                     //      while (getchar() != '\n'); 
                                     //      1) scanf:       w 입력/저장  → 버퍼에 ad\n 유지
                                     //      2) getchar:     a 읽고 비움  → 버퍼에  d\n 유지
                                     //      3) getchar:     d 읽고 비움  → 버퍼에   \n 유지
                                     //      4) getchar:    \n 읽고 비움  → while  반복 종료
        if (control_input == 'w')
        {
            printf("GO\n");
            continue;
        }
        else if (control_input == 'a')
        {
            printf("LEFT\n");
            continue;
        }
        else if (control_input == 'd')
        {
            printf("RIGHT\n");
            continue;
        }
        else if (control_input == 's')
        {
            printf("STOP\n");
            continue;
        }
        else if (control_input == 'x')
        {
            printf("BACK\n");
            continue;
        }
        else if (control_input == 'q')
        {
            printf("Quit\n");
            break;
        }
        else
        {
            printf("Error input : ");
            printf("%c \n", control_input);
            break;
        }
    }

    return 0;
}

// // Explanation for Line 10
// int main()
// {
//     // 1)
//     while (조건/조건식);

//     // 2)
//     while (조건/조건식)
//     {
       
//     }
//     // 1) = 2) 

//     return 0;
// }
```

EOF = End of File
문자를 읽는 프로그램에서 문자를 끝까지 읽었을 경우 EOF 값(= -1)을 반환
→ OS/Language에서 정한 파일의 끝을 나타내는 상수(= -1 in C Language)

Ctrl + Z (Window OS) + 엔터 & Ctrl + D (Mac OS) + 엔터 터미널에 입력
→ Code에서 EOF 입력/저장

**h\_3\_continue\_break\_2\_b\_eof.c**

```awk
#include <stdio.h>

int main()
{
    char input = 0;

    while (input != EOF)         // while (input != -1): 버퍼의 첫번째 문자의 ASCII Code 변환 정수 = -1이 아닐때 까지 읽음
                                 //  =  문자의 ASCII Code 변환 정수 = -1 없음
                                 //  =  문자 무한 Loop 읽음
                                 // 예: 실제 파일의 Text를 읽는 프로그 램 작성 시 필요할수 있음          
    {
        input = getchar();       // 첫번째 문자 읽음
                                 // 예:   Wad\n 입력시 \n까지 읽고 다음 입력 대기
                                 // Ctrl + Z(Ctrl + D) 입력시 아랫줄에서 -1 출력 후 while문 반복 종료
        printf("%c\n", input);
        printf("%d\n", input);
    }

    return 0;
}
```
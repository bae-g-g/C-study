# Array  (&X)

# **Array 배열**

### Prerequisite Understanding
E.g)
int X = 5;
int \*X\_ptr;
X\_ptr = &X; // 일반 포인터 변수 = 일반 변수 주소값
\*X\_ptr = 5 = X; // 일반 변수 주소값이 가르키는/참조하는 값/변수
※ 포인터 변수 = 일반 변수의 주소값: X\_ptr = &X
int X = 5; → 변수 X의 주소값(첫번째 Byte)를 시작으로 정수 5 초기화
★ X\_ptr = 일반 변수 X의 주소값 = &X
↓ 한차원 아래
\*X\_ptr = 일반 변수 X의 주소값이 가르키는/참조하는 값/변수 = 5 = X
★ X\_ptr(= &X)의 자료형 = 일반 변수 X의 주소값의 자료형 = int \*
int 포인터 (변수)
↓ 한차원 아래
\*X\_ptr의 자료형 = 일반 변수 X의 주소값이 가르키는/참조하는 값/변수의 자료형 = int
int 정수

Ref) 포인터 변수(= 주소값)보다
\*포인터 변수(= 주소값이 가르키는/참조하는 값/변수)는 한차원 ↓
\= 변수의 주소값 아래에 변수값이 초기화

![](https://t9003081320.p.clickup-attachments.com/t9003081320/16cf1a63-973b-48a3-a5f5-7563cb4cf362/Picture1.png)
E.g)
int Y\[5\] = {1, 2, 3, 4, 5};
int \*Y\_ptr;
Y\_ptr = Y; // Y\_ptr = &Y\[0\]; 배열 포인터 변수 = 배열 변수 Y →(붕괴)→ 배열 Y 0번째 주소값
\*Y\_ptr = 1; // 배열 Y의 0번째 주소값(= 배열 변수 Y)가 가르키는/참조하는 값/변수
※ 배열 포인터 변수 = 배열 변수 →(붕괴)→ 배열 0번째 주소값: Y\_ptr = Y →(붕괴)→ &Y\[0\]
int Y\[5\] = {1, 2, 3, 4, 5}; → 배열 Y의 0번째 주소값(첫번째 Byte)를 시작으로 정수 1~5 초기화
i.e) 배열 변수 Y →(붕괴)→ 배열의 0번째 주소값 &Y\[0\] = 배열 포인터 변수 Y\_ptr
∴ int Y\[5\];
scanf("%s", &Y); // scanf("%s", Y); Y →(붕괴)→ &Y\[0\] i.e. Y 값 = Y 배열 0번째 주소값
//  &Y ≒ Y →(붕괴)→ &Y\[0\]
// **∵** &Y = Y = &Y\[0\] 값은 동일 But 의미는 상이
`scanf %s + &변수` → 변수의 주소값(0번째 주소값 = 첫번째 Byte)을 시작으로 초기화
&Y:
배열 Y의 전체 주소값 첫번째 Byte를 시작으로 초기화
Y →(붕괴)→ &Y\[0\]:
배열 Y의 0번째 주소값 첫번째 Byte를 시작으로 초기화
★ Y\_ptr = 배열 변수 Y →(붕괴)→ 배열 Y의 0번째 주소값 &Y\[0\]
↓ 한차원 아래
\*Y\_ptr = 배열 Y의 0번째 주소값(= 배열 변수 Y)이 가르키는/참조하는 값/변수 = Y\[0\] = 1
★ Y\_ptr(= Y →(붕괴)→ &Y\[0\])의 자료형 = 배열 변수→(붕괴)→배열 0번째 주소값의 자료형
\= int \*
int 포인터 (배열)
Ref) int Y\[5\] = {1, 2, 3, 4, 5};
Y 자료형 = int \[\] →(붕괴)→ &Y\[0\] 자료형 = int \*= int \*
int 배열 int 포인터 (배열)

↓ 한차원 아래
\*Y\_ptr = 배열 Y의 0번째 주소값이 가르키는/참조하는 값/변수의 자료형 = int
int 정수
Ref) 배열 포인터 변수(= 배열의 0번째 주소값)보다
\*배열 포인터 변수(= 배열의 0번째 주소값이 가르키는/참조하는 값)는 한차원 ↓
\= 배열 0번째 주소값 아래에 변수값이 초기화

E.g)
int Z\[3\] = {1, 2, 3};
int(\*Z\_ptr)\[3\];
Z\_ptr = &Z //  배열 전체 포인터 변수 = 배열 전체 Z의 주소값
\*Z\_ptr = Z →(붕괴)→ &Z\[0\] // 배열 전체 Z의 주소값이 가르키는/참조하는 값/변수
※ 배열 전체 포인터 변수 = 배열(전체) 주소값 : &Z
int Z\[3\] = {1, 2, 3}; → 배열 전체 Z의 주소값(첫번째 Byte)를 시작으로 정수 1~3 초기화
★ Z\_ptr = 배열 전체 Z의 주소값 = &Z
↓ 한차원 아래
\*Z\_ptr = 배열 전체 Z의 주소값이 가르키는/참조하는 값/변수
\= 배열 변수 Z →(붕괴)→ 배열 전체 Z의 0번째 주소값
\= &Z\[0\]
★ Z\_ptr(= &Z)의 자료형 = 배열 전체 Z의 주소값의 자료형 = int (\*) \[\]
int 포인터 배열 전체
↓ 한차원 아래
\*Z\_ptr의 자료형 = 배열 전체 Z의 주소값이 가르키는/참조하는 값/변수의 자료형
\= int \[\] →(붕괴)→ int \*
int 배열 int 포인터 (배열)

Ref) 배열 전체 포인터 변수(= 배열 전체의 주소값)보다
\*배열 전체 포인터 변수(= 배열 전체의 주소값이 가르키는/참조하는 값)는 한차원 ↓
\= 배열 전체의 주소값 아래에 배열 변수 →(붕괴)→ 배열의 0번째 주소값이 초기화
※※※
배열 전체 포인터 변수 Z\_ptr = 배열 전체 Z의 주소값 &Z
≒ 배열 변수 Z →(붕괴)→ 배열 Z의 0번째 주소값 Z →(붕괴)→ &Z\[0\]
*   값 Value는 서로 동일
*   의미 Mean은 서로 유사
★ &X : 주소값 상수 + 배열 범위 = 배열 X의 전체 주소값
★ &X\[0\]: 주소값 상수 = 배열 X의 0번째 주소값

### &X\[0\] vs X vs &X
![](https://t9003081320.p.clickup-attachments.com/t9003081320/c7d88671-afeb-4f7f-822d-cf7d6511f27f/Picture1.png)

| int X = 5;<br>int \*X\_ptr;<br>X\_ptr = &X; // 일반 포인터 변수 = 일반 변수 주소값<br>\*X\_ptr = 5 = X; // 일반 변수 주소값이 가르키는/참조하는 값/변수 |
| --- |
| X\_ptr | &X | int \* |
| ↓ 한차원 아래 |
| \*X\_ptr | 5 = X | int |
|  |
| int Y\[5\] = {1, 2, 3, 4, 5};<br>int(\*A\_ptr)\[5\];<br>A\_ptr = &Y; // 배열 전체 포인터 변수 = 배열 전체 Y의 주소값<br>\*A\_ptr = Y →(붕괴)→ &Y\[0\]; // 배열 전체 Y의 주소값이 가르키는/참조하는 값/변수<br><br>int \*B\_ptr;<br>B\_ptr = &Y\[0\]; // B\_ptr = Y; 배열 포인터 변수 = 배열 Y의 0번째 주소값 = 배열 변수 Y<br>\*B\_ptr = 1; // 배열 Y의 0번째 주소값(= 배열 변수 Y)가 가르키는/참조하는 값/변수<br>\*(\*A\_ptr) = 1; |
| A\_ptr | &Y | int (\*)\[ \] |
| ↓ 한차원 아래 |  |  |
| \*A\_ptr = B\_ptr | Y →(붕괴)→ &Y\[0\] | int \[ \] →(붕괴)→ int \* |
| ↓ 한차원 아래 |
| \*B\_ptr = \*(\*A\_ptr) | Y\[0\] = 1 | int |

**c\_pointer\_array\_0a.c**

```cpp
#include <stdio.h>

int main()
{   
    // Reference 1:  일반 변수
    int D = 5;
    printf(" Pre_D = %d\n", D);
    int *D_ptr = &D;
    *D_ptr = 10;
    printf("Post_D = %d\n", D);
    
    // Reference 2:  배열 변수
    int B[3] = {4, 5, 6};
    int C[3] = {7, 8, 9}; 
    B = C;                 // 배열 B = 배열 C  →(붕괴)→  배열 B의 0번째 주소값(&B[0])을 배열 C의 0번째 주소값(&C[0])로 변경" 한다는 의미
                           // 안되는 이유 1)  배열은 배열전체 복사 불가:  배열요소 각각 변경 要
                           // 안되는 이유 2)  배열은 포인터로 붕괴 → 처음 선언한 배열의 주소값을 변경하려는 동작(같은 주소값 or 다른 주소값) 불가
    
    // Application:  배열 변수
    int A[3] = {1, 2, 3};
    int(*A_ptr)[3];
    A_ptr = &A; 
    *A_ptr = A;            // 배열 A = 배열 A   →(붕괴)→  배열 A의 0번째 주소값(&A[0])을 배열 A의 0번째 주소값(&A[0] = A)로 변경 
                           // 참고 2: 안되는 이유 1) + 안되는 이유 2)
    return 0;
}     
    
```

**c\_pointer\_array\_0b.c**

```perl
#include <stdio.h>

int main()
{
    int X[3] = {1, 2, 3};

    int(*arr_ptr_1)[3];
    arr_ptr_1 = &X;

    int *arr_ptr_2; // 선언   자료형:  int *  포인터 변수 자료형
    arr_ptr_2= X;   // 초기화 자료형:  X →(붕괴)→ &X[0]  포인터 변수 자료형

    printf("%d\n", &X);
    printf("%d\n", arr_ptr_1);
    printf("%d\n", *&X);
    printf("%d\n", *arr_ptr_1);
    printf("%d  %d  %d\n", *&(X[0]), *&(X[1]), *&(X[2])); // *&X[0], *&X[1], *&X[2]

    printf("=======\n");

    printf("%d\n", X);
    printf("%d\n", &X[0]);
    printf("%d\n", arr_ptr_2);
    printf("%d\n", *X);
    printf("%d\n", *&X[0]);
    printf("%d\n", *arr_ptr_2);
    // printf("%d  %d  %d\n", **&(X[0]), **&(X[1]), **&(X[2]));

    return 0;
}
```

* * *

## **&X**
(上) #1 Array to Pointer Decay X 배열 변수→배열 포인터 변수 붕괴 X: (不) X→&X\[0\]
(上) #1-1 &Array Variable &배열 변수

### #1 Declaration/Initialisation/Use 선언/초기화/사용

#### #1-1 배열 전체 포인터 변수 선언 및 초기화
`자료형 (*변수)[배열 크기]`
자료형 (\*배열 전체 포인터 변수)\[배열 크기: 가르키는/참조하는 값/변수 범위\]
→ 배열 전체 주소값(≒ 배열 0번째 주소값의 첫번째 Byte) 초기화 역할
→ 배열 크기 지정 要
∵ 배열 전체 주소값의 영향력 범위 지정 역할
\= 배열 전체 주소값이 가르키는/참조하는 값/변수의 범위 파악 역할
∴ `자료형`: 주소값이 가르키는값/참조하는 값/변수의 자료형 +( `*` )+ 자료형크기(배열크기)
예:
int (\*)\[ \], char (\*)\[ \], float (\*)\[ \]
int 포인터 배열 전체

∴ 포인터 변수 자료형 = 주소값 상수 초기화 = &X\[0\] (배열 0번째 주소값)
↓ ↓
자료형에 \[ \] 배열 크기 지정 = (주소값 상수 + 배열 범위) 초기화 = &X (배열 전체 주소값)

E.g)
int X\[3\]; // int 배열 선언
int(\*arr\_ptr)\[3\] = &X; // 배열 전체 포인터 변수 선언 및 초기화

※ int X\[3\]; 선언시
PC 내부적으로 int(\*arr\_ptr\_1)\[3\] 통해
메모리박스 생성 시작/끝 위치 할당/확인 가능 O
![](https://t9003081320.p.clickup-attachments.com/t9003081320/c816b9e9-00b9-4fdf-8555-4948fcb882da/1.png)
∃ int X\[3\]; // X ➝ (붕괴 O)➝ &X\[0\]
PC 내부적으로 메모리박스 생성 시작/끝 위치 할당/확인 가능 O

#### #1-2 포인터와 배열 전체 포인터 변수 사용
`*변수`
포인터+배열 전체 포인터 변수
→ 배열 전체 포인터 변수에 초기화된 배열 전체 주소값이 가르키는/참조하는 값/변수
→ 배열 전체 포인터 변수의 반환값(Return 값)
\= 배열 전체 주소값이 가르키는/참조하는 값/변수
\= 배열 →(포인터로 붕괴 X)→ ~~배열 0번째 주소값~~ ※ Array to Pointer Decay X Case
∴ `자료형`: 주소값이 가르키는값/참조하는 값/변수의 자료형 + `*`
예:
int \[ \], char \[ \], float \[ \] ➝(붕괴)➝ int \*, char \*, float \*
배열 포인터

E.g)
![](https://t9003081320.p.clickup-attachments.com/t9003081320/c525e965-89c2-4021-a162-976bec1df0ef/Picture1.png)

int X\[3\]; // int 배열 선언
int(\*arr\_ptr)\[3\] = &X; // 배열 전체 포인터 변수 선언 및 초기화
※ arr\_ptr = 배열 전체 포인터 변수 = &X
`자료형`: int 포인터 배열 전체 / int (\*)\[\]

↓ 한차원 아래

\*arr\_ptr = 배열 전체 포인터 변수가 가르키는/참조하는 값/변수
\= 배열 = X
↓ (포인터로 붕괴 O)
\= 배열 0번째 주소값 = &X\[0\]
`자료형`: int \[ \] / int 배열 ➝(붕괴)➝ int \* (배열) / int 포인터 (배열)

↓ 한차원 아래

\*\*arr\_ptr = 배열 전체 포인터 변수가 가르키는/참조하는 값/변수가 가르키는/참조하는 값/변수
\= &X\[0\]이 가르키는/참조하는 값/변수
\= 배열 0번째 요소
`자료형`: int

E.g)
int X = 5;
int \*X\_ptr = &X;
※ X\_ptr이 가르키는 값 = 5

int X\[3\] = {1, 2, 3};
int \*X\_ptr = X; // X ➝(붕괴)➝ &X\[0\]
※ X\_ptr이 가르키는 값 = \*(&X\[0\]) = 배열 0번째 요소 = 1

int X\[3\] = {1, 2, 3};
int (\*X\_ptr)\[3\] = &X
※ X\_ptr이 가르키는 값 = \*(&X) = X ➝(붕괴)➝ &X\[0\]

**c\_pointer\_array\_7.c**

```perl
#include <stdio.h>

int main()
{
    int X[3] = {65, 66, 67};   // 배열 선언
    int(*X_ptr)[3];            // 1)   선언   자료형: int (*)[]  포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화
                               // 2)   초기화 자료형: &X         포인터 변수 자료형: 주소값 상수 + 배열 범위
                               // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X
    X_ptr = &X;

    printf("%d\n", &X);        
    printf("%d\n", *&X);       
    printf("%d\n", **&X);      

    printf("\n%d\n", X_ptr);   //    &X 
    printf("%d\n", *X_ptr);    //  *(&X) =  X →(붕괴 O)→   &X[0]
    printf("%d\n", **X_ptr);   // **(&X) = *X →(붕괴 O)→ *(&X[0]) = X[0] 

    return 0;
} 


```

### #2 Array Pointer Variable ± Operation 배열 전체 포인터 변수 ± 연산

#### #2-1 Array Pointer Variable + int
배열 전체 포인터 변수 + int 정수
#### #2-2 Array Pointer Variable – int
배열 전체 포인터 변수 – int 정수

#### 사전 이해)
![](https://t9003081320.p.clickup-attachments.com/t9003081320/c525e965-89c2-4021-a162-976bec1df0ef/Picture1.png)

#### 개념 이용)
사칙연산 (+ – \* /)
연산 객체 "**단위"**만큼 + – \* /
예:
2 \+ 3 = 5
*   2: 10진수
*   \+ 3: 10진수 단위에서 3만큼 증가
*   \= 5: 10진수 2에 10진수 단위로 3만큼 증가한 값

∴

| ※ "연산 단위가" 무엇인가? |
| --- |
| ※ "연산 단위"는 "± int 정수"를 의미 |
| ※ "± int 정수"의 의미(크기)가 무엇인가? |
| 예: ± 1 에서 "1"이 의미(크기)가 무엇인가? |

i.e.
![](https://t9003081320.p.clickup-attachments.com/t9003081320/3da0cbc8-ca48-4f9a-bcce-7b23e2320943/%EA%B7%B8%EB%A6%BC3.png)

↓ (한차원 아래)

![](https://t9003081320.p.clickup-attachments.com/t9003081320/39aebcd3-5302-4ca1-811c-f86dd06c1a70/%EA%B7%B8%EB%A6%BC4.png)
↓ (동일 의미)
![](https://t9003081320.p.clickup-attachments.com/t9003081320/a2123076-98e0-4e2f-8893-66706534a3b3/%EA%B7%B8%EB%A6%BC5.png)

포인터 변수 +1 = 포인터 변수가 가르키는/참조하는 값의 크기만큼 +
포인터 변수 \-1 = 포인터 변수가 가르키는/참조하는 값의 크기만큼 -
⇒
배열 전체 포인터 변수 +1 = 배열 전체 포인터 변수가 가르키는값의 크기만큼 +
\= 배열 전체 주소값이 가르키는 값의 크기만큼 +
\= 배열 크기만큼 +
\= sizeof(X) ➝(붕괴 X) 만큼 +
\= (배열 요소 자료형 크기 4 Bytes or 1 Byte x 배열 요소 갯수) 만큼 +
배열 전체 포인터 변수 \-1 = 배열 전체 포인터 변수가 가르키는 값의 크기만큼 -
\= 배열 전체 주소값이 가르키는 값의 크기만큼 -
\= 배열 크기만큼 -
\= sizeof(X) ➝(붕괴 X) 만큼 -
\= (배열 요소 자료형 크기 4 Bytes or 1 Byte x 배열 요소 갯수) 만큼 -

↓ (한차원 아래)

\*배열 전체 포인터 변수 +1 = (\*배열 전체 포인터 변수)가 가르키는값의 크기만큼 +
\= (\*배열 전체 주소값)이 가르키는 값의 크기만큼 +
\= (배열 ➝(붕괴 O)➝ 배열 0번째 주소값)이 가르키는 값의 크기만큼 +
\= (X ➝(붕괴 O)➝ &X\[0\])이 가르키는 값의 크기만큼 +
\= sizeof(&X\[0\] 아래에 초기화된 값)만큼 +
\= int/float: + 4Bytes int/float: + 4Bytes or char: + 1or char: + 1
\*배열 전체 포인터 변수 \-1 = (\*배열 전체 포인터 변수)가 가르키는값의 크기만큼 -
\= (\*배열 전체 주소값)이 가르키는 값의 크기만큼 -
\= (배열 ➝(붕괴 O)➝ 배열 0번째 주소값)이 가르키는 값의 크기만큼 -
\= (X ➝(붕괴 O)➝ &X\[0\])이 가르키는 값의 크기만큼 -
\= sizeof(&X\[0\] 아래에 초기화된 값)만큼 -
\= int/float: - 4Bytes or char: - 1

E.g)
int X\[3\] = {65, 66, 67};
int(\*X\_ptr)\[3\] = &X

⇒
포인터 변수 + 1
X\_Ptr + 1
&X + 1
배열 전체 주소값 + 자기 자신(의 메모리박스 크기)
배열 전체 주소값 + 배열 전체 주소값의 범위(의 메모리박스 크기)
배열 전체 주소값 + 배열 0번째 ~ 마지막번째 주소값(의 메모리박스 크기)
배열 전체 주소값 + 배열 X의 크기
&X + sizeof(X)
&X + 배열 X의 요소 크기 \* 배열 X의 요소 갯수
&X + 4 Bytes \* 3
&X + 12

⇒
\*포인터 변수 + 1
\*X\_Ptr + 1
\*&X + 1
배열 전체 주소값이 가르키는 값 + \*자기 자신(의 메모리박스 크기)
배열 전체 주소값이 가르키는 값 + \*배열 전체 주소값의 범위(의 메모리박스 크기)
배열 전체 주소값이 가르키는 값 + \*배열 0번째 ~ 마지막번째 주소값(의 메모리박스 크기)
배열 전체 주소값이 가르키는 값 + 배열 X가 가르키는 값의 크기
\*&X + sizeof(\*X)
\*&X + sizeof(\*X) ➝(붕괴)➝ sizeof(\*&X\[0\])
\*&X + sizeof(X\[0\])
X + sizeof(X\[0\])
X➝(붕괴)➝&X\[0\] + sizeof(X\[0\])
&X\[0\] + 4

#### 자료형 이용)
※ 배열 전체 포인터 변수(= 배열 전체 주소값)의 크기
\= 8 Bytes (64 Bits OS)
★ 배열 전체 주소값이 초기화된 메모리박스 크기 = 8 Bytes

※ 배열 전체 포인터 변수(= 배열 전체 주소값)의 연산 (예: ± 1)
± 1
\= ± 배열 전체 포인터 변수의 자료형이 가르키는/참조하는 값의 크기
int (\*)\[\] int \[\] ➝(붕괴 X) ※ sizeof(X) ➝(붕괴 X)
\= ± 배열 크기(배열 요소 자료형 크기 4 Bytes or 1 Byte x 배열 요소 갯수)
sizeof(X)
∴ 배열 전체 주소값 ± 배열 크기 ※ 자료형: int (\*)\[ \] ➝(한차원 아래)➝ sizeof(int \[\])

↓ 한차원 아래
※ \*배열 전체 포인터 변수(= \*배열 전체 주소값)의 연산 (예: ± 1)
± 1
\= ± 배열 전체 포인터 변수의 자료형이 int (\*)\[\]
가르키는/참조하는 값의 자료형이 int \[\] ➝(붕괴 O)➝ int \*
가르키는/참조하는 값의 크기 int ※ sizeof(int)
\= ± 4 Bytes (float: 4 Bytes / char: 1 Byte)
∴ 배열 0번째 주소값 ± 4 Bytes (1 Byte) ※ 자료형: int \* ➝(한차원 아래)➝ sizeof(int)

↓ 한차원 아래
※ \*\*배열 전체 포인터 변수(= \*\*배열 전체 주소값)의 연산 (예: ± 1)
± 1
\= ± 배열 전체 포인터 변수의 자료형이 int (\*)\[\]
가르키는/참조하는 값의 자료형이 int \[\] ➝(붕괴 O)➝ int \*
가르키는/참조하는 값의 자료형이 int
가르키는/참조하는 값의 크기 1 ※ sizeof(1)
\= ± 1
∴ 배열 0번째 요소 ± 1 ※ 자료형: int ➝(한차원 아래)➝ sizeof(1)

※※※
배열 전체 포인터 변수 ± int n
\= 배열 전체 주소값 ± 배열 전체 포인터 변수의 자료형이 가르키는/참조하는 값의 크기
i.e. 배열 전체 주소값 ± (배열 크기 x n)
↓ 한차원 아래
\*배열 포인터 변수 ± int n
\= 배열 0번째 주소값 ± 배열 포인터 변수 자료형이 가르키는/참조하는 값/변수의 크기
i.e. 배열 0번째 주소값 ± (배열요소 자료형 크기 x n)
↓ 한차원 아래
\*\*배열 포인터 변수 ± int n
\= 배열 0번째 요소 ± int n

**c\_pointer\_array\_8a.c**

```perl
#include <stdio.h>

int main()
{
    int X[3] = {65, 66, 67};       // 배열 선언
    int(*X_ptr)[3];                // 1)   선언   자료형: int (*)[]  포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화
                                   // 2)   초기화 자료형: &X         포인터 변수 자료형: 주소값 상수 + 배열 범위
                                   // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X
    X_ptr = &X;

    printf("%d\n", &X);        
    printf("%d\n", *&X);       
    printf("%d\n", **&X);  

    printf("======================\n");    

    printf("\n%d\n", X_ptr + 1);   //    &X  + 1   =   &X + &X(= X_ptr)의 자료형(= int (*)[])이 가르키는 값의 크기  =  &X + int []의 크기  =  &X + 배열 X 크기  =  &X + sizeof(X ➝ 붕괴 X: ∵ sizeof 함수)  =  &X + sizeof(X)  =  &X + (4 Bytes + 3개)  =  &X + 12 
    printf("%d\n", *X_ptr + 1);    //  *(&X) + 1   =    X + 배열 X의 자료형(= int [] →(붕괴 O)→ int *)이 가르키는 값의 크기  =  X + int의 크기  =   (X →(붕괴 O)→ &X[0]) + (sizeof(int))  =  &X[0] + 4
    printf("%d\n", **X_ptr + 1);   // **(&X) + 1   =   *X + *X의 자료형(= int)이 가르키는 값의 크기  =  *X + 1의 크기  =  *X + sizeof(1)  =  *X + 1  =  (*X →(붕괴 O)→ *(&X[0])) + 1  =  X[0] + 1  =  65 + 1

    return 0;
} 


```

**c\_pointer\_array\_8b.c**

```perl
#include <stdio.h>

int main()
{
    int X[3] = {65, 66, 67};                        // 배열 선언
    int(*X_ptr)[3];                                 // 1)   선언   자료형: int (*)[]  포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화
                                                    // 2)   초기화 자료형: &X         포인터 변수 자료형: 주소값 상수 + 배열 범위
                                                    // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X
    X_ptr = &X;

    printf("%d + 1 = %d\n", &X, &X + 1);                    
    printf("%d + 1 = %d\n", *&X, *&X + 1);             
    printf("%d + 1 = %d\n", **&X, **&X + 1);         

    printf("======================\n");

    printf("%d + 1 = %d\n", X_ptr, X_ptr + 1);       
    printf("%d + 1 = %d\n", *X_ptr, *X_ptr + 1);     
    printf("%d + 1 = %d\n", **X_ptr, **X_ptr + 1);  

    return 0;}
// int + int → Bit 연산
// float + float → 지수부 연산 + 가수부 연산
// 포인터 변수 + int 정수(예: 3)  → 포인터 변수의 자료형이 가르키는 값의 크기 만큼(예: x 3) 연산


```

**c\_pointer\_array\_8c.c**

```perl
#include <stdio.h>

int main()
{
    int X[3] = {65, 66, 67};                        // 배열 선언
    int(*X_ptr)[3];                                 // 1)   선언   자료형: int (*)[]  포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화
                                                    // 2)   초기화 자료형: &X         포인터 변수 자료형: 주소값 상수 + 배열 범위
                                                    // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X
    X_ptr = &X;

    printf("%d - 1 = %d\n", &X, &X - 1);                
    printf("%d - 1 = %d\n", *&X, *&X - 1);             
    printf("%d - 1 = %d\n", **&X, **&X - 1);    

    printf("======================\n");
    
    printf("%d - 1 = %d\n", X_ptr, X_ptr - 1);      
    printf("%d - 1 = %d\n", *X_ptr, *X_ptr - 1);    
    printf("%d - 1 = %d\n", **X_ptr, **X_ptr - 1); 

    return 0;
}


```

#### #2-3 Array Pointer Variable – Array Pointer Variable
배열 전체 포인터 변수 – 배열 전체 포인터 변수
#### #2-4 Array Pointer Variable + Array Pointer Variable
배열 전체 포인터 변수 + 배열 전체 포인터 변수

#### 사전 이해)
![](https://t9003081320.p.clickup-attachments.com/t9003081320/c525e965-89c2-4021-a162-976bec1df0ef/Picture1.png)

#### 개념 이용)
사칙연산 (+ – \* /)
연산 객체 "**단위"**만큼 + – \* /
예:
2 \+ 3 = 5
*   2: 10진수
*   \+ 3: 10진수 단위에서 3만큼 증가
*   \= 5: 10진수 2에 10진수 단위로 3만큼 증가한 값

∴

| ※ "연산 단위가" 무엇인가? |
| --- |
| ※ "연산 단위"는 "포인터 변수"를 의미 |
| ※ "포인터 변수"의 의미(크기)가 무엇인가? |
| 예: ± 포인터 변수 에서 "포인터 변수"의 의미(크기)가 무엇인가? |

i.e.
※ 포인터 변수 - 포인터 변수
예: \*(&X + 1) - \*(&X)
Step 1: 각 연산 대상 객체가 포인터 변수(주소값)인지 int 정수 인지 확인
\*(&X + 1) = 포인터 변수(주소값) ? or int 정수 ?
\*(&X) = 포인터 변수(주소값) ? or int 정수 ?
Step 2: If \*(&X + 1) && \*(&X) = 포인터 변수(주소값)
⇒ 포인터 변수(주소값) 간의 Bit 연산(= int 정수 연산)
\*(&X + 1) - \*(&X) = Y
Step 3: Y를 포인터 변수(주소값)의 자료형이 가르키는 값의 크기로 나눔
Y ÷ sizeof(\*(int (\*)\[ \]))
\= Y ÷ sizeof(int \[ \]➝(붕괴 X))
\= Y ÷ sizeof(X)
\= Y ÷ (배열 X 요소 크기 x 배열 X 요소 갯수)
∵ 포인터 변수 - 포인터 변수 의미
\= 포인터 변수(주소값)간의 차이가 포인터 변수 자료형이 갖는 크기/범위 대비 얼마?
E.g)
9 - 3 = 6
6 = 9와 3의 차이가
10진수 대비 6
E.g)
int (\*)\[ \] - int (\*)\[ \] = n
n = int (\*)\[ \] 와 int (\*)\[ \] 의 포인터 변수(주소값)간의 차이가
포인터 변수 자료형이 갖는 크기/범위(0번째 주소값 ~ 크기/범위) 대비 n

![](https://t9003081320.p.clickup-attachments.com/t9003081320/3d450b3e-5e79-4491-a5dc-ce2cea27c617/%EA%B7%B8%EB%A6%BC11.png)

↓ (한차원 아래)

![](https://t9003081320.p.clickup-attachments.com/t9003081320/e4a424c0-d16f-4d1c-8d2d-cf7bc19dd4f8/%EA%B7%B8%EB%A6%BC12.png)
∴ 주소값 간의 Bit 연산(= int 정수 연산)
÷ 예1: 배열 크기 (배열 요소 크기  4 Bytes or 1 Byte  x  배열 요소 갯수)
주소값 간의 Bit 연산(= int 정수 연산)
÷ 예2: 요소 크기 (4 Bytes or 1 Byte)

※ 포인터 변수 + 포인터 변수
\= Compiling Error  
∵ C Language에 정의되지 않은 연산:   Huge 주소값 + Huge 주소값 → Overflow 발생 가능성 O

**c\_pointer\_array\_9a.c**

```perl
#include <stdio.h>

int main()
{
    int X = 5;
    int *X_ptr_1 = &X;        // 1)   선언   자료형: int *  포인터 변수 자료형: 주소값 상수 
                              // 2)   초기화 자료형: &X     포인터 변수 자료형: 주소값 상수 
                              // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr에 초기화:  X_ptr_1 = &X
    int *X_ptr_2 = &X + 1;

    printf("%d - %d = %d\n", &X + 1, &X, &X + 1 - &X);               // Step 1:  &X + 1 = 포인터 변수,   &X = 포인터 변수   ∴   &X + 1 - &X = 포인터 변수 - 포인터 변수
                                                                     // Step 2:  포인터 변수 int 연산  =  (&X + 1 - &X)
                                                                     // Step 3:  ÷ 포인터 변수 자료형이 가르키는 값의 크기 = int *가 가르키는 값의 크기 = int의 크기 = sizeof(int) = 4 Bytes 
                                                                     // ∴  &X + 1 - &X  =  (&X + 1 - &X) / sizeof(X)  =  4 / 4  =  1
    printf("%d - %d = %d\n", X_ptr_2, X_ptr_1, X_ptr_2 - X_ptr_1);

    return 0;
}    
      
```

**c\_pointer\_array\_9b.c**

```perl
#include <stdio.h>

int main()
{
    int X[3] = {65, 66, 67};
    int(*X_ptr_1)[3];
    int(*X_ptr_2)[3];

    X_ptr_1 = &X;
    X_ptr_2 = &X + 1;

    printf("======================\n");
    printf("%d - %d = %d\n", &X + 1, &X, (&X + 1) - &X);     // 포인터 변수 - 포인터 변수 O
    printf("%d - %d = %d\n", &X + 1, &X, &X + 1 - (&X));     // 포인터 변수 - 포인터 변수 O
    printf("%d - %d = %d\n", &X + 1, &X, (&X + 1 - &X));     // 포인터 변수 - 포인터 변수 O
    // printf("%d - %d = %d\n", &X + 1, &X, &X + (1 - &X));  // 1) 1 - &X = int 정수 - 포인터 변수 주소값:        int 정수 1이 &X 앞에 있어, int 정수 1이 &X에 맞춰 포인터 변수 주소값 연산 단위로 변환 X  
                                                             //                                                  ∴   연산단위 불일치  →  연산 불가능 O  →  Compiling Error
                                                             //    Ref) printf("%d\n", &X - (&X - 1)); 
                                                             //        (&X - 1) = 포인터 변수 주소값 - int 정수:  int 정수 1이 &X 뒤에 있어, int 정수 1이 &X에 맞춰 포인터 변수 주소값 연산 단위로 변환 O
                                                             //                                                  ∴   연산단위 일치  →  연산 가능 O  →  Compiling 
                                                             // 2) 포인터 변수 + 포인터 변수 X  →  Compiling Error
    printf("%d\n", &X - (&X - 1));

    printf("======================\n");
    printf("%d - %d = %d\n", X_ptr_1 + 1, X_ptr_1, (X_ptr_1 + 1) - X_ptr_1);   // 포인터 변수 - 포인터 변수 O
    printf("%d - %d = %d\n", X_ptr_1 + 1, X_ptr_1, X_ptr_1 + 1 - (X_ptr_1));   // 포인터 변수 - 포인터 변수 O
    printf("%d - %d = %d\n", X_ptr_1 + 1, X_ptr_1, (X_ptr_1 + 1 - X_ptr_1));   // 포인터 변수 - 포인터 변수 O
    // printf("%d - %d = %d\n", X_ptr_1 + 1, X_ptr_1, X_ptr_1 + (1 - X_ptr_1));  // 포인터 변수 + 포인터 변수 X  →  Compiling Error
    
    printf("======================\n");
    printf("%d - %d = %d\n", X_ptr_2, X_ptr_1, X_ptr_2 - X_ptr_1);             // 포인터 변수 - 포인터 변수 O

    return 0;
}


```

**c\_pointer\_array\_9c.c**

```plain
#include <stdio.h>

int main()
{
    int X[3] = {65, 66, 67};
    int(*X_ptr_1)[3];
    // 1)   선언   자료형: int (*)[]  포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화
    // 2)   초기화 자료형: &X         포인터 변수 자료형: 주소값 상수 + 배열 범위
    // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X     
    int(*X_ptr_2)[3];

    X_ptr_1 = &X;
    X_ptr_2 = &X + 1;

    printf("===========(1: &X)===========\n");
    printf("%d - %d = %d\n", &X + 1, &X, &X + 1 - &X);
    // &X = 포인터 변수(값)
    // &X + 1 - &X = 포인터 변수 - 포인터 변수 (O)          
    // X:  (배열 요소 자료형 크기 4 Bytes x 배열 크기/배열 요소 갯수 3 = 12가 증가한 주소값) - (원래 주소값) = 12 ?!?!?  
    // O:   포인터 변수(주소값)의 int 연산 결과 / 포인터 변수 자료형이 가르키는 값의 크기
    //      12 / *(int (*)[])의 크기
    //      12 / int [] →(붕괴 X) 의 크기
    //      12 / 배열 X의 크기
    //      12 / sizeof(X)
    //      12 / 12 = 1

    printf("%d - %d = %d\n", *&X + 1, *&X, *&X + 1 - *&X);
    // *&X = X →(붕괴 O)→ &X[0] = 포인터 변수(값)
    // *&X + 1 - *&X = 포인터 변수 - 포인터 변수 (O)
    // X:  (4 Bytes가 증가한 주소값) - (원래 주소값) = 4 ?!?!?
    // O:  포인터 변수(주소값)가 가르키는 값의 int 연산 결과 / 포인터 변수 자료형이 가르키는 값의 자료형이 가르키는 값의 크기
    //     4 / **(int (*)[])의 크기
    //     4 / *(int [] →(붕괴 O)→ int *)의 크기
    //     4 / int의 크기
    //     4 / sizeof(int)
    //     4 / 4 = 1
    printf("%d - %d = %d\n", **&X + 1, **&X, **&X + 1 - **&X);
    // **&X = *X →(붕괴 O)→ *(&X[0]) = X[0] = int 정수
    // ∴     **&X + 1 - **&X = 포인터 변수 - 포인터 변수 (X)  →  int 정수 - int 정수 (O)    
    // i.e.  X[0] + 1 - X[0] = 65 + 1 - 65 = 1 

    printf("===========(2: X_ptr_1)===========\n");
    printf("%d - %d = %d\n", X_ptr_1 + 1, X_ptr_1, X_ptr_1 + 1 - X_ptr_1);
    printf("%d - %d = %d\n", *X_ptr_1 + 1, *X_ptr_1, *X_ptr_1 + 1 - *X_ptr_1);
    printf("%d - %d = %d\n", **X_ptr_1 + 1, **X_ptr_1, **X_ptr_1 + 1 - **X_ptr_1);

    printf("===========(3: X_ptr_2)===========\n");
    printf("%d - %d = %d\n", X_ptr_2, X_ptr_1, X_ptr_2 - X_ptr_1);
    // 1) &X + 1 = 포인터 변수
    // 2) &X     = 포인터 변수
    // &X + 1 - &X = 포인터 변수 - 포인터 변수 (O)
    // 포인터 변수(주소값)의 int 연산 결과 / 포인터 변수 자료형이 가르키는 값의 크기
    // 12 / *(int (*)[])의 크기
    // 12 / int [] →(붕괴 X) 의 크기
    // 12 / 배열 X의 크기
    // 12 / sizeof(X)
    // 12 / 12 = 1
    printf("%d - %d = %d\n", *X_ptr_2, *X_ptr_1, *X_ptr_2 - *X_ptr_1);         
    // 1) *(&X + 1): = *(배열 전체 주소값 + int(*)[]이 가르키는 값의 크기)
    //               = *(배열 전체 주소값 + sizeof(int []))
    //               = *(배열 전체 주소값 + sizeof(X) →(붕괴 X))
    //               = *(배열 전체 주소값 + (4 Bytes x 3개 = 12))
    //               = *(옆 전체 배열의 주소값)
    //               =   옆 전체 배열의 주소값이 가르키는 값
    //               = 옆 배열 →(붕괴 O)→ 옆 배열 0번째 주소값  
    //               = 포인터 변수(값)
    // 2) *(&X):     *(&X)
    //               = X →(붕괴 O)→ &X[0] 
    //               = 포인터 변수(값)
    // *(&X + 1) - *(&X):  포인터 변수 - 포인터 변수 (O)
    // 1) - 2)       포인터 변수(주소값)의 int 연산 결과 / 포인터 변수의 자료형이 가르키는 값의 크기
    //               = (옆 배열의 0번째 주소값) - (X 배열의 0번째 주소값) / 배열의 0번째 주소값의 자료형이 가르키는 값의 크기
    //               = (옆 배열의 0번째 주소값) - (X 배열의 0번째 주소값) / int *이 가르키는 값의 크기
    //               = (옆 배열의 0번째 주소값) - (X 배열의 0번째 주소값) / sizeof(int)
    //               = (옆 배열과  X 배열 주소값 차이 = X 배열 전체 크기 = (배열 요소 크기 4 Bytes x 배열 요소 갯수 3 = 12)) / 4 Bytes
    //               = 3
    printf("%d - %d = %d\n", **X_ptr_2, **X_ptr_1, **X_ptr_2 - **X_ptr_1);    
    // **&X = *X →(붕괴 O)→ *(&X[0]) = X[0]
    // Window OS
    // 1) **(&X + 1): 59~65번째줄에 의해 
    //                = 옆 배열의 0번째 주소값(= *(&X + 1))이 가르키는 값
    //                = 옆 배열의 0번째 요소 ?!?!?  →  옆 배열의 0번째 요소 無: 옆 배열 선언 되지않아 0번째 참조 X
    //                ⇒   옆 배열의 0번째 주소값(= *(&X + 1))이 가르키는 값의 근원(本 Root)
    //                     = (배열 X의 전체 주소값 + (4 Bytes x 3개 = 12))이 가르키는 값
    //                     = (&X + 1)이 가르키는 값
    //                     = 옆 배열 전체 주소값이 가르키는 값
    //                     = 옆 배열 →(붕괴 O)→ 옆 배열의 0번째 주소값 
    //                     = 옆 배열의 0번째 주소"값" = (&X + 1)의 주소"값"  (※ 의미는 다름) 
    //                     = (&X + 1) 주소값 = 포인터 변수 (O)  
    //                     = (&X + 1) 주소값 →(형변환: 81번째줄에 의해 자료형에 Fitting, i.e. 옆 배열의 0번째 요소 자료형 int에 Fitting)
    //                     = (&X + 1) 주소값의 int 정수 처리
    //                     = int 정수
    // ∴ **(포인터 변수 = 주소값):  주소값이 여러번 가르켰을 때(예: 2번 가르켰을 때 - 가르킨 값이 가르킨 값을 구할 때),  "메모리박스 할당이 안되어있으면", 결국 자기 자신의 주소값을 초기화여 가르킴
    // 아래 코드 참조
// int main()
// {   
//     // int Y[3] = {1, 2, 3};
//     int X[3] = {65, 66, 67};
//     int(*X_ptr_1)[3];
//     int(*X_ptr_2)[3];

//     **(&X + 1) = 68;
//     printf("%d\n",**(&X + 1));
    
//     X_ptr_1 = &X;
//     X_ptr_2 = &X + 1;
//     printf("%d\n",**(&X + 1));
// ∴ **(포인터 변수 = 주소값):  주소값이 여러번 가르켰을 때(예: 2번 가르켰을 때 - 가르킨 값이 가르킨 값을 구할 때),  "메모리박스 할당이 안되어있으면", 결국 자기 자신의 주소값을 초기화여 가르킴
// ∴ **(포인터 변수 = 주소값):  주소값이 여러번 가르켰을 때(예: 2번 가르켰을 때 - 가르킨 값이 가르킨 값을 구할 때),  "메모리박스 할당이 되어있으면 (98번째줄)",  주소값이 초기화된 요소를 참조함

//     return 0;
// }

    // 2) **(&X):    **(&X)
    //               = *X →(붕괴 O)→ *(&X[0])
    //               = X[0] 
    //               = int 정수
    // **(&X + 1) - **(&X): 포인터 변수 - 포인터 변수 (X)  →  int 정수 - int 정수 (O)
    // 1) - 2)       옆 배열의 0번째 주소값이 가르키는 값 - X[0]
    //               = 80~81번째줄에 의해 (&X + 1)의 주소값의 int 정수 처리 형 - X[0]
    // Mac OS
    // 1) **(&X + 1): 59~65번째줄에 의해 
    //                = 옆 배열의 0번째 주소값(= *(&X + 1))이 가르키는 값
    //                = 옆 배열의 0번째 요소 ?!?!?  →  옆 배열의 0번째 요소 無  →  옆 배열의 0번째 메모리박스 내 쓰레기값 참조 하게됨  
    //                                                                          ∵ Mac OS에서 선언으로 인한 메모리박스 생성 위치(주소)는 Compiling 마다 Random 생성
    //                                                                          ∴ 지정된 주소값 無  →  자기 자신(本 Root = 주소값) 無          
    //                = 옆 배열의 0번째 메모리박스 내 쓰레기값도 Compiling 마다 Changed (Ref:  Window OS에서도 쓰레기값은 Compiling 마다 Changed)
    //                = 옆 배열의 0번째 메모리박스 내 Compiling 마다 Changeable 쓰레기값 
    //                = int 정수 
    // 2) **(&X):    **(&X)
    //               = *X →(붕괴 O)→ *(&X[0])
    //               = X[0] 
    //               = int 정수
    // **(&X + 1) - **(&X): 포인터 변수 - 포인터 변수 (X)  →  int 정수 - int 정수 (O) 
    // 1) - 2)       옆 배열의 0번째 메모리박스 내 Compiling 마다 Changeable 쓰레기값  - X[0]
    return 0;
}
// 포인터 변수 - 포인터 변수 =  주소값 Bit 연산(= 주소값 int 연산) / 포인터 변수의 자료형이 가르키는 값의 크기
//                            주소값 Bit 연산(= 주소값 int 연산) / 예1: 배열 전체 크기 (배열 요소 자료형 크기  4 Bytes or 1 Byte  x  배열 크기/배열 요소 갯수)
//                            주소값 Bit 연산(= 주소값 int 연산) / 예2: 배열 요소 크기 (배열 요소 자료형 크기: 4 Bytes or 1 Byte)
// 포인터 변수 + 포인터 변수 =  Compiling Error  ∵ C언어 내에 정의되지 않은 연산:  Huge 주소값 + Huge 주소값 → Overflow 발생 가능성 O


```

### #3 Array Pointer Variable Size 배열 전체 포인터 변수 크기

포인터 변수(= 주소값) 크기 = 8 Bytes

**c\_pointer\_array\_10a.c**

```plain
#include <stdio.h>
int main()
{
    int X[3] = {65, 66, 67};           
    int(*X_ptr)[3];                    
    X_ptr = &X;
    // 1)   선언   자료형: int (*)[]  포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화
    // 2)   초기화 자료형: &X         포인터 변수 자료형: 주소값 상수 + 배열 범위
    // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X

    printf("%d\n", sizeof(&X));        // int (*)[]  포인터 변수 크기
    printf("%d\n", sizeof(*&X));       // sizeof(X) →(붕괴 X)  =  배열 X 크기 = 배열 요소 자료형 크기 * 배열 요소 갯수
                                       // ⇒  *  +  &  = 개념상 상쇄:  ※ 권장 풀이 X
    printf("%d\n", sizeof(**&X));      // sizeof(*X)  =  sizeof(*X) →(붕괴 O)→ sizeof(*&X[0])  =  sizeof(X[0])  

    printf("\n%d\n", sizeof(X_ptr)); 
    printf("%d\n", sizeof(*X_ptr));  
    printf("%d\n", sizeof(**X_ptr)); 

    return 0;
}


#include <stdio.h>
int main()
{
    int X[3] = {65, 66, 67}; 
    int *X_ptr;                         
    X_ptr = &X[0];
    // 1)   선언   자료형: int *   포인터 변수 자료형: 주소값 상수 초기화
    // 2)   초기화 자료형: X →(붕괴 O)→ &X[0]  포인터 변수 자료형: : 주소값 상수
    // ⇒   선언 자료형 = 초기화 자료형  i.e. &X[0]의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X[0]                   

    printf("%d\n", sizeof(&X[0]));      // int * 포인터 변수 크기      
    printf("%d\n", sizeof(X));          // sizeof(X) →(붕괴 X)  =  배열 X 크기 = 배열 X 요소 자료형 크기 * 배열 요소 갯수     
    printf("%d\n", sizeof(X_ptr));      // int * 포인터 변수 크기    

    printf("==================\n");

    printf("%d\n", sizeof(X_ptr));      // int * 포인터 변수 크기                                              // =  sizeof(&X[0])   
    printf("%d\n", sizeof(*X_ptr));     // int * 자료형이 가르키는 값의 크기  =  int의 크기  =  sizeof(int)     // =  sizeof(X[0])
    // printf("%d\n", sizeof(**X_ptr));   // int 자료형이 가르키는 값???? 의 크기 → Code Error                  // =  sizeof(X[0]가 가르키는 값????) → Code Error

    return 0;
}


```

**c\_pointer\_array\_10b.c**

```perl
#include <stdio.h>

int main()
{
    int X[3] = {65, 66, 67};           
    int(*X_ptr)[3];                 
    X_ptr = &X;
    // 1)   선언   자료형: int (*)[]  포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화
    // 2)   초기화 자료형: &X         포인터 변수 자료형: 주소값 상수 + 배열 범위
    // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X    

    printf("%d\n", sizeof(&X));        // int (*)[]  포인터 변수 크기
    printf("%d\n", sizeof(*&X));       // sizeof(X) →(붕괴 X)  =  배열 X 크기 = 배열 X 요소 자료형 크기 * 배열 요소 갯수
    printf("%d\n", sizeof(**&X));      // sizeof(*X)  =  sizeof(*X) →(붕괴 O)→ sizeof(*&X[0])  =  sizeof(X[0])  

    printf("==================\n");

    printf("%d\n", sizeof(&X));        //  sizeof(&X)
    printf("%d\n", sizeof(&*X));       //  &*(X) 크기 →(붕괴 O)→  &*(&X[0]) 크기 =  &(X[0]) 크기  =  int 65의 주소값의 크기 
    printf("%d\n", sizeof(*&*X));      // *&*(X) 크기 →(붕괴 O)→ *&*(&X[0]) 크기 = *&(X[0]) 크기  =  int 65의 주소값이 가르키는 값의 크기 = int 65의 크기

    return 0;
}


```

### #4 Pointer Variable & Array Variable Use 배열 전체 포인터 변수 사용

#### #4-1 General 일반

#### 사전 이해)
![](https://t9003081320.p.clickup-attachments.com/t9003081320/c525e965-89c2-4021-a162-976bec1df0ef/Picture1.png)

#### 개념 이용)
E.g)
int X\[5\] = {1, 2, 3, 4, 5};
int(\*X\_ptr\_1)\[5\] = &X; // X\_ptr\_1 = &X
int \*X\_ptr\_2 = X; // X\_ptr\_2 = X ➝(붕괴)➝ &X\[0\]

X\_ptr\_1\[A\]\[B\]
\= (&X)\[A\]\[B\]
*   (&X)\[0\]

\= (&X) ➝(전체 배열 주소값의 한차원 아래 0번째)➝ \[0\]

\= 배열 X ➝ (붕괴)➝ &X\[0\]

*   (&X)\[1\]

\= (&X) ➝(전체 배열 주소값의 한차원 아래 1번째)➝ \[1\]

\= 배열 X 옆배열 Y➝ (붕괴)➝ &Y\[0\]

*   (&X)\[0\]\[0\]

\= (&X) ➝(전체 배열 주소값의 한차원 아래 0번째)➝ \[0\] ➝(&X\[0\] 한차원 아래 0번째)➝ \[0\]

\= X\[0\]

*   (&X)\[0\]\[1\]

\= (&X) ➝(전체 배열 주소값의 한차원 아래 0번째)➝ \[0\] ➝(&X\[0\] 한차원 아래 1번째)➝ \[1\]

\= X\[1\]

X\_ptr\_2\[C\]
\= (&X\[0\])\[C\]
*   (&X\[0\])\[0\]

\= (&X\[0\]) ➝(배열 X 0번째 주소값의 한차원 아래 0번째)➝ \[0\]

\= X\[0\]

*   (&X\[0\])\[1\]

\= (&X\[0\]) ➝(배열 X 0번째 주소값의 한차원 아래 1번째)➝ \[1\]

\= X\[1\]

**c\_pointer\_array\_11a.c**

```plain
#include <stdio.h>

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int(*X_ptr)[5];              
    X_ptr = &X;
    // 1)   선언   자료형: int (*)[]  포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화
    // 2)   초기화 자료형: &X         포인터 변수 자료형: 주소값 상수 + 배열 범위
    // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X

    // 전체배열 주소 이용하여 요소 출력 Method 1
                                                    // 개념) 2차원 배열 방식
                                                    // 참조) X[0]: 배열 X의 "한차원 아래" 0번째 요소 = (&X[0])[0]: 배열 X 0번째 주소값 0번째 요소 = 배열 X 0번째 주소값"에서" 0번째 요소 =  배열 X 0번째 주소값 "바로 아래" 요소
                                                    // 참조) X[1]: 배열 X의 "한차원 아래" 1번째 요소 = (&X[0])[1]: 배열 X 0번째 주소값 1번째 요소 = 배열 X 0번째 주소값"에서" 1번째 요소
    printf("*X_ptr[0]: %d\n", X_ptr[0]);            // X_ptr[0] = (&X)[0] = 전체 배열 주소값의 "한차원 아래" 0번째 = 전체 배열 주소값의 바로 아래 = 배열 X →(붕괴)→ &X[0]
    printf("*X_ptr[1]: %d\n", X_ptr[1]);            // X_ptr[1] = (&X)[1] = 전체 배열 주소값의 "한차원 아래" 1번째 = 전체 배열 주소값에서 1번째 = 배열 X의 오른쪽 옆 배열 Y 가정 →(붕괴)→ &Y[0] 가정  
    printf("*X_ptr[0][0]: %d\n", X_ptr[0][0]);      // X_ptr[0][0] = (&X)[0][0] = (&X[0])[0] = 배열 X 0번째 주소값에서 1번째 요소 
    printf("*X_ptr[0][1]: %d\n", X_ptr[0][1]);
    printf("*X_ptr[0][2]: %d\n", X_ptr[0][2]);
    printf("*X_ptr[0][3]: %d\n", X_ptr[0][3]);
    printf("*X_ptr[0][4]: %d\n", X_ptr[0][4]);

    X_ptr[0][0] = 11;                               // X_ptr[0][0] = (&X)[0][0] = (&X[0])[0] = 배열 X 0번째 주소값에서 1번째 요소 11로 초기화
    printf("*X_ptr[0][1]: %d\n", X_ptr[0][0]);

    // // 전체배열 주소 이용하여 요소 출력 Method 2
    // printf("**X_ptr: %d\n", **X_ptr);   //  *X_ptr = *(&X) = X →(붕괴)→ &X[0]
    //                                         // **X_ptr = *(&X[0]) = X[0] 
 
    // // 전체배열 주소 이용하여 요소 출력 Method 3
    // for (int i = 0; i < 5; i++)
    // {
    //     printf("*X_ptr[0][%d]: %d\n", i, X_ptr[0][i]);  // X_ptr[0] = (&X)[0] = 배열 X →(붕괴)→ &X[0]
    //                                                     // X_ptr[0][i] = (&X)[0][i] =  (&X[0])[i] = 배열 X 0번째 주소값에서 0 ~ 4번째 요소 
    // }

    // // 전체배열 주소 이용하여 요소 출력 Method 4
    // (*X_ptr)[0] = 22;                   // (*X_ptr) = *(&X) = 배열 X →(붕괴)→ &X[0]  →  (*X_ptr)[0] = (&X[0])[0] = 배열 X 0번째 주소값 0번째 요소 = 배열 X 0번째 주소값에서 0번째 요소 =  배열 X 0번째 주소값 바로 아래 요소 = X[0]
    // printf("**X_ptr: %d\n", **X_ptr);   //  *X_ptr  = *(&X) = 배열 X →(붕괴)→ &X[0]  →  **X_ptr = *(&X[0]) = X[0] = 22
    // for (int i = 0; i < 5; i++)
    // {
    //     printf("(*X_ptr)[%d]: %d\n", i, (*X_ptr)[i]); // (*X_ptr) = *(&X) = 배열 X →(붕괴)→ &X[0]  →  (*X_ptr)[i] = (&X[0])[i] = 배열 X 0번째 주소값에서 0 ~ 4번째 요소
    //     // printf(" *X_ptr [%d]: %d\n", i, *X_ptr[i]);
    //     // // *X_ptr[i]  =  *(X_ptr[i])
    //     // //               *(X_ptr[0])  =  *((&X)[0])  =  *(배열 X) →(붕괴)→ *(&X[0])  =  X[0]
    //     // //               *(X_ptr[1])  =  *((&X)[1])  =  *(배열 X의 오른쪽 옆 배열 Y 가정) →(붕괴)→ *(&Y[0] 가정)  =  Y[0]    
    //     // // ※ *X_ptr[i]는  *(X_ptr[i])
    // }

    // // 전체배열 주소 이용하여 요소 출력 Method 5
    // for (int i = 0; i < 5; i++)
    // {
    //     printf("*(X_ptr[0]) + %d: %d\n", i, *(X_ptr[0] + i)); 
    //     //   X_ptr[0] = (&X)[0] = 배열 X →(붕괴)→ &X[0]
    //     //   X_ptr[0] + 1  = &X[0] + 1 = &X[0] + (연산단위) 
    //     //                             = &X[0] + &X[0]의 자료형이 가르키는 값의 크기 = &X[0] + int *의 자료형이 가르키는 값의 크기 = &X[0] + int의 크기 = &X[0] + sizeeof(int) = &X[0] + 4 Bytes = &X[1]
    //     // *(X_ptr[0] + 1) = *(&X[1]) = X[1]
    // }

    // // 전체배열 주소 이용하여 요소 출력 Method 6
    // for (int i = 0; i < 5; i++)
    // {
    //     printf("*((*X_ptr) + %d): %d\n", i, *((*X_ptr) + i));
    //     //   (*X_ptr) = *(&X) = 배열 X →(붕괴)→ &X[0]
    //     //   (*X_ptr) + 1  = &X[0] + 1 = &X[0] + (연산단위) 
    //     //                             = &X[0] + &X[0]의 자료형이 가르키는 값의 크기 = &X[0] + int *의 자료형이 가르키는 값의 크기 = &X[0] + int의 크기 = &X[0] + sizeeof(int) = &X[0] + 4 Bytes = &X[1]
    //     // *((*X_ptr) + 1) = *(&X[1]) = X[1]
    // }
    
    return 0;
}


```

#### #4-2 Function 함수
배열 &X

![](https://t9003081320.p.clickup-attachments.com/t9003081320/c525e965-89c2-4021-a162-976bec1df0ef/Picture1.png)

|  | 변수 int char float | 배열 X ➝(붕괴)➝ &X\[0\] | 배열 &X |
| ---| ---| ---| --- |
| 사용자정의 함수 | 매개변수<br>int \* A<br>A = &X<br><br><br><br>매개변수<br>int \* A\_ptr\_1<br>A\_ptr\_1 = X\_ptr\_1<br><br>※ A = A\_ptr\_1<br>※ 자료형<br>int \* | 매개변수<br>int A\[5\] = int \*A<br><br>※ A ➝(붕괴)➝ &A\[0\]<br>X ➝(붕괴)➝ &X\[0\]<br><br>매개변수<br>int \* A\_ptr\_2<br>A\_ptr\_2 = \_ptr\_2<br><br>※ A = A\_ptr\_2<br>※ 자료형<br>int\[ \] ➝(붕괴)➝ int \* (배열) | 매개변수<br>int (\*A) \[5\]<br>A\_ptr\_3 = &X<br><br><br><br>매개변수<br>int (\* A\_ptr\_3) \[5\]<br>A\_ptr\_3 = X\_ptr\_3<br><br>※ A = A\_ptr\_3<br>※ 자료형<br>int (\*)\[ \] int \* (배열 전체) |
| ↑ | ↑ | ↑ | ↑ |
| 메인 함수 | 인수<br>&X = X\_ptr\_1 | 인수<br>X ➝(붕괴)➝ &X\[0\] = X\_ptr\_2 | 인수<br>&X = X\_ptr\_3 |

**※ Array Variable vs Pointer Variable (1)**

| Array Variable | int \[\] | int 배열 |
| ---| ---| --- |
| 붕괴 (O) ↓ |
| Pointer Variable | int \* | int 포인터 (배열) |
|  |
| Pointer Variable | int (\*)\[\] | int 포인터 전체 배열 |
| 붕괴 (X) ↓ |
|  |
| Array Variable | int \*\[\]<br>int \*를 \[\]개 있는 배열 | int 포인터 배열 |
| 붕괴 (O) ↓ |
| Pointer Variable | int \*\* | int 이중 포인터 |

**※ Array Variable vs Pointer Variable (2)**

| Array Variable |  | Pointer Variable |  |
| ---| ---| ---| --- |
| int \[\] | ➝붕괴 (O)➝ | int \* |  |
| \- |  | int (\*)\[\] | ➝붕괴 (X)➝ |
| int \*\[\]<br>int \*를 \[\]개 있는 배열 | ➝붕괴 (O)➝ | int \*\* |  |

**※ Array Variable vs Pointer Variable (3) in Array**
*   &X\[0\]: 주소값 상수 = 배열 X의 0번째 주소값
*   &X : 주소값 상수 + 배열 범위 = 배열 X의 전체 주소값
★ X ➝(붕괴 O)➝ &X\[0\] 값 = &X 값

|  | Data Type | Object 목적 | Initialised Value 실제 초기화 값 |
| ---| ---| ---| --- |
| int \*\* | Pointer Variable<br>➝붕괴 (X) | 배열 전체 주소값 &X<br>∴ 자료형:<br>&X 초기화를 대상 | &X 전체 주소값을<br>주소값 상수로만 저장 = &X\[0\] |
| int (\*)\[\] | Pointer Variable<br>➝붕괴 (X) | 배열 전체 주소값 &X<br>∴ 자료형:<br>&X 초기화를 대상 | 자료형 형식 \[\]에 의해<br>주소값의 영향력 범위를 포함한<br>전체 주소값 저장 = &X |

**c\_pointer\_array\_11b.c**

```plain
#include <stdio.h>

void function_1(int (*Y)[5])        // Y의 자료형:  int (*)[] = 포인터 변수 자료형:  주소값 상수 + 배열 범위 초기화 = &X  
                                    // Y의 초기화:  인수 &X  →  매개변수 Y = &X                  
{
    printf("%d\n", Y);              //   Y = &X         
    printf("%d\n", *Y);             //  *Y = *(&X) = X →(붕괴 O)→ &X[0] 
    printf("%d\n", *(Y + 1));       // *(Y + 1) = *(&X + &X의 자료형이 가르키는 값의 크기) = *(&X + int (*)[]이 가르키는 값의 크기) = *(&X + int []의 크기) = *(&X + sizeof(X)) = *(&X + sizeof(Y)) 
                                    //          = X 전체 배열의 오른쪽 옆 전체 배열이 가르키는 값 = X 전체 배열의 오른쪽 옆 배열 →(붕괴 O)→ X 전체 배열 오른쪽 옆 배열의 0번째 주소값
    printf("%d\n", *Y + 1);         //  *Y + 1  = *(&X) + 1 = X + 1 = X→(붕괴 O)→&X[0] + 1 = &X[0] + 1 
                                    //          = &X[0] + &X[0]의 자료형이 가르키는 값의 크기 = &X[0] + int *가 가르키는 값의 크기 = &X[0] + int의 크기 = &X[0] + sizeof(int) = &X[0] + 4 Bytes = &X[1]
}

void function_2(int (*Y_ptr_1)[5])  // Y_ptr_1의 자료형:  int (*)[] = 포인터 변수 자료형:  주소값 상수 + 배열 범위 초기화 = &X  
                                    // Y_ptr_1의 초기화:  인수 X_ptr_1 = &X  →  매개변수 Y_ptr_1 = &X                 
{
    printf("%d\n", Y_ptr_1);        //   Y_ptr_1 = &X      
    printf("%d\n", *Y_ptr_1);       //  *Y_ptr_1 = *(&X) = X →(붕괴 O)→ &X[0]   
    printf("%d\n", *(Y_ptr_1 + 1)); // *(Y_ptr_1 + 1) = *(&X + &X의 자료형이 가르키는 값의 크기) = *(&X + int (*)[]이 가르키는 값의 크기) = *(&X + int []의 크기) = *(&X + sizeof(X)) = *(&X + sizeof(Y)) 
                                    //                = X 전체 배열의 오른쪽 옆 전체 배열이 가르키는 값 = X 전체 배열의 오른쪽 옆 배열 →(붕괴 O)→ X 전체 배열 오른쪽 옆 배열의 0번째 주소값
    printf("%d\n", *Y_ptr_1 + 1);   //  *Y_ptr_1 + 1 = *(&X) + 1 = X + 1 = X→(붕괴 O)→&X[0] + 1 = &X[0] + 1 
                                    //               = &X[0] + &X[0]의 자료형이 가르키는 값의 크기 = &X[0] + int *가 가르키는 값의 크기 = &X[0] + int의 크기 = &X[0] + sizeof(int) = &X[0] + 4 Bytes = &X[1]
}

// Reference 1
void function_3(int Y[5])           // Y의 자료형:  int [] →(붕괴 O)→ int *  (X →(붕괴 O)→ &X[0])  =  포인터 변수 자료형:  주소값 상수 = &X[0]  
                                    // Y의 초기화:  인수 &X  →(형변환)→  매개변수 Y = &X[0]                       
{
    printf("%d\n", Y);              //   Y = &X[0]
    printf("%d\n", *Y);             //  *Y = *(&X[0]) = X[0] 
    printf("%d\n", *(Y + 1));       // *(Y + 1) = *(&X[0] + &X[0]의 자료형이 가르키는 값의 크기) = *(&X[0] + int *가 가르키는 값의 크기) = *(&X[0] + int의 크기) = *(&X[0] + sizeof(int)) = *(&X[0] + 4 Bytes) = *(&X[1]) = X[1]
    printf("%d\n", *Y + 1);         //  *Y + 1  = *(&X[0]) + 1 = X[0] + 1
}

// Reference 2
void function_4(int *Y_ptr_1)       // Y의 자료형:  int * = 포인터 변수 자료형:  주소값 상수 = &X[0]  
                                    // Y의 초기화:  인수 X_ptr_1 = &X  →(형변환)→  매개변수 Y_ptr_1 = &X[0]  
{
    printf("%d\n", Y_ptr_1);        //   Y_ptr_1 = &X[0]   
    printf("%d\n", *Y_ptr_1);       //  *Y_ptr_1 = *(&X[0]) = X[0] 
    printf("%d\n", *(Y_ptr_1 + 1)); // *(Y_ptr_1 + 1) = *(&X[0] + &X[0]의 자료형이 가르키는 값의 크기) = *(&X[0] + int *가 가르키는 값의 크기) = *(&X[0] + int의 크기) = *(&X[0] + sizeof(int)) = *(&X[0] + 4 Bytes) = *(&X[1]) = X[1]
    printf("%d\n", *Y_ptr_1 + 1);   //  *Y_ptr_1 + 1  = *(&X[0]) + 1 = X[0] + 1
}

// Reference 3
void function_5(int (*Y_ptr_2)[5])  // Y_ptr_2의 자료형:  int (*)[] = 포인터 변수 자료형:  주소값 상수 + 배열 범위 초기화 = &X  
                                    // Y_ptr_2의 초기화:  인수 X_ptr_2 = &X[0] →(형변환)→  매개변수 Y_ptr_2 = &X            
{
    printf("%d\n", Y_ptr_2);        //   Y_ptr_2 = &X 
    printf("%d\n", *Y_ptr_2);       //  *Y_ptr_2 = *(&X) = X →(붕괴 O)→ &X[0]    
    printf("%d\n", *(Y_ptr_2 + 1)); // *(Y_ptr_2 + 1) = *(&X + &X의 자료형이 가르키는 값의 크기) = *(&X + int (*)[]이 가르키는 값의 크기) = *(&X + int []의 크기) = *(&X + sizeof(X)) = *(&X + sizeof(Y)) 
                                    //                = X 전체 배열의 오른쪽 옆 전체 배열이 가르키는 값 = X 전체 배열의 오른쪽 옆 배열 →(붕괴 O)→ X 전체 배열 오른쪽 옆 배열의 0번째 주소값
    printf("%d\n", *Y_ptr_2 + 1);   // *Y_ptr_2 + 1   = *(&X) + 1 = X + 1 = X→(붕괴 O)→&X[0] + 1 = &X[0] + 1 
                                    //                = &X[0] + &X[0]의 자료형이 가르키는 값의 크기 = &X[0] + int *가 가르키는 값의 크기 = &X[0] + int의 크기 = &X[0] + sizeof(int) = &X[0] + 4 Bytes = &X[1]
}

// Reference 4
void function_6(int *Y_ptr_2)       // Y_ptr_2의 자료형:  int * = 포인터 변수 자료형:  주소값 상수 = &X[0]  
                                    // Y_ptr_2의 초기화:  인수 X_ptr_2 = &X[0]  →  매개변수 Y_ptr_2 = &X[0]  
{
    printf("%d\n", Y_ptr_2);        //   Y_ptr_2 = &X[0]   
    printf("%d\n", *Y_ptr_2);       //  *Y_ptr_2 = *(&X[0]) = X[0] 
    printf("%d\n", *(Y_ptr_2 + 1)); // *(Y_ptr_2 + 1) = *(&X[0] + &X[0]의 자료형이 가르키는 값의 크기) = *(&X[0] + int *가 가르키는 값의 크기) = *(&X[0] + int의 크기) = *(&X[0] + sizeof(int)) = *(&X[0] + 4 Bytes) = *(&X[1]) = X[1]
    printf("%d\n", *Y_ptr_2 + 1);   //  *Y_ptr_2 + 1  = *(&X[0]) + 1 = X[0] + 1
} 

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int (*X_ptr_1)[5] = &X;         // 1)   선언   자료형: int (*)[]  포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화
                                    // 2)   초기화 자료형: &X         포인터 변수 자료형: 주소값 상수 + 배열 범위
                                    // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr_1에 초기화:    X_ptr_1 = &X     
    int *X_ptr_2 = &X;              // 1)   선언   자료형: int *   포인터 변수 자료형: 주소값 상수 초기화
                                    // 2)   초기화 자료형: &X      포인터 변수 자료형: 주소값 상수 + 배열 범위
                                    // ⇒   선언 자료형 ≠ 초기화 자료형  i.e. &X →(형변환)→ &X[0]이 X_ptr_2에 초기화:  X_ptr_2= &X[0]       

    function_1(&X);    
    function_2(X_ptr_1);
    function_3(&X);
    function_4(X_ptr_1);
    function_5(X_ptr_2);
    function_6(X_ptr_2);            
 
    return 0;
}


```

**c\_pointer\_array\_11c.c**

```plain
#include <stdio.h>

void function_1(int array[5])                    // array의 자료형:  int [] →(붕괴 O)→ int *  (X →(붕괴 O)→ &X[0])  =  포인터 변수 자료형:  주소값 상수 = &X[0]  
                                                 // array의 초기화:  인수 &X  →(형변환)→  매개변수 array = &X[0]     
{
    printf("function_1\n");
    printf("array size: %d\n", sizeof(array));   // sizeof(&X[0]) = 8 Bytes
}

void function_2(int (*ptr)[5])                   // ptr의 자료형:  int (*)[] = 포인터 변수 자료형:  주소값 상수 + 배열 범위 초기화 = &X  
                                                 // ptr의 초기화:  인수 &X  →  매개변수 ptr = &X
{
    printf("function_2\n");
    printf("*ptr size: %d\n", sizeof(*ptr));     // sizeof(*ptr) = sizeof(*&X) =  sizseof(X) →(붕괴 X):  배열 X 크기 = 4 Bytes * 5개 = 20

}

void function_3(int (*ptr)[10])                  // ptr의 자료형:  int (*)[] = 포인터 변수 자료형:  주소값 상수 + 배열 범위 초기화 = &X  
                                                 // ptr의 초기화:  인수 &X  →  매개변수 ptr = &X 
{
    printf("function_3\n");
    printf("*ptr size: %d\n", sizeof(*ptr));     // sizeof(*ptr) = sizeof(*&X) =  sizseof(X) →(붕괴 X):  배열 X 크기 = 4 Bytes * 10개 = 40
}

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int (*X_ptr)[5] = &X;                        // 1)   선언   자료형: int (*)[]  포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화
                                                 // 2)   초기화 자료형: &X         포인터 변수 자료형: 주소값 상수 + 배열 범위
                                                 // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr에 초기화:    X_ptr = &X

    printf("========X Size========\n");
    printf("X size: %d\n", sizeof(X));           // sizeof(X) →(붕괴 X):  배열 X 크기 = 4 Bytes * 5개 = 20

    printf("==========&X==========\n");
    function_1(&X);                               
    function_2(&X);
    function_3(&X);

    printf("========X_ptr=======\n");
    function_1(X_ptr);
    function_2(X_ptr);
    function_3(X_ptr);

    return 0;
}


```

**c\_pointer\_array\_11d.c**

```plain
#include <stdio.h>

void function_1(int array[5], int size)          // array의 자료형:  int [] →(붕괴 O)→ int *  (X →(붕괴 O)→ &X[0])  =  포인터 변수 자료형:  주소값 상수 = &X[0]  
                                                 // array의 초기화:  인수 &X  →(형변환)→  매개변수 array = &X[0]
{
    printf("function_1\n");
    printf("array size: %d,  parameter size: %d\n", sizeof(array), size);  // sizeof(&X[0]) = 8 Bytes, 20 Bytes
}

void function_2(int (*ptr)[5], int size)         // ptr의 자료형:  int (*)[] = 포인터 변수 자료형:  주소값 상수 + 배열 범위 초기화 = &X  
                                                 // ptr의 초기화:  인수 &X  →  매개변수 ptr = &X                                  
{
    printf("function_2\n");
    printf("*ptr size: %d,  parameter size: %d\n", sizeof(*ptr), size);   // sizeof(*&X) = sizeof(X) →(붕괴 X):  배열 X 크기 = 4 Bytes * 5개 = 20 Bytes, 20 Bytes
}

void function_3(int (*ptr)[10], int size)        // ptr의 자료형:  int (*)[] = 포인터 변수 자료형:  주소값 상수 + 배열 범위 초기화 = &X  
                                                 // ptr의 초기화:  인수 &X  →  매개변수 ptr = &X   
{
    printf("function_3\n");
    printf("*ptr size: %d,  parameter size: %d\n", sizeof(*ptr), size);   // sizeof(*&X) = sizeof(X) →(붕괴 X):  배열 X 크기 = 4 Bytes * 10개 = 40 Bytes, 20 Bytes
}

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int(*X_ptr)[5] = &X;                         // 1)   선언   자료형: int (*)[]  포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화
                                                 // 2)   초기화 자료형: &X         포인터 변수 자료형: 주소값 상수 + 배열 범위
                                                 // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr에 초기화:    X_ptr = &X

    printf("===X Size===\n");
    printf("X size: %d\n", sizeof(X));           // sizeof(X) →(붕괴 X):  배열 X 크기 = 4 Bytes * 5개 = 20   

    printf("====================&X====================\n");
    function_1(&X, sizeof(X));
    function_2(&X, sizeof(X));
    function_3(&X, sizeof(X));

    printf("===================X_ptr==================\n");
    function_1(X_ptr, sizeof(*X_ptr));           // sizeof(*X_ptr) = sizeof(*&X) = sizeof(X) →(붕괴 X):  배열 X 크기 = 4 Bytes * 5개 = 20
    function_2(X_ptr, sizeof(*X_ptr));
    function_3(X_ptr, sizeof(*X_ptr));

    return 0;
}
// 1) 사용자정의 함수 출력 부분에서 sizeof(): 메인 함수의 인수값이 동일하나 사용자정의 함수의 매개변수 값은 상이
// 2) 사용자정의 함수 출력 부분에서     size: 메인 함수의 인수값이 동일하여 사용자정의 함수의 매개변수 값도 동일
// ∴  실제 배열의 크기를 사용자정의 함수에서 사용하기 위해서 2) 사용


```

**c\_pointer\_array\_11e.c**

```plain
#include <stdio.h>

void function_1(int array[5], int size)                 // array의 자료형:  int [] →(붕괴 O)→ int *  (X →(붕괴 O)→ &X[0])  =  포인터 변수 자료형:  주소값 상수 = &X[0]  
                                                        // array의 초기화:  인수 &X  →(형변환)→  매개변수 array = &X[0]  
                                                        // 매개변수 size = 20    
{
    printf("function_1\n");
    for (int i = 0; i < size / sizeof(array[0]); i++)   // size / sizeof(array[0]) = 20 / sizeof(&X[0][0]) = 20 / sizeof(0번째 주소값을 시작으로 0번째 요소) 
                                                        //                         = 20 / sizeof(X[0]) = 20 / 4 = 5
    {
        printf("%d번째 값 %d\n", i, array[i]);           // array[i] = &X[0][i] = 배열 0번째 주소값을 시작으로 0~4번째 요소 출력 = 배열 X 0~4번째 요소 출력 
    }
}

void function_2(int (*ptr)[5], int size)                // ptr의 자료형:  int (*)[] = 포인터 변수 자료형:  주소값 상수 + 배열 범위 초기화 = &X  
                                                        // ptr의 초기화:  인수 &X  →  매개변수 ptr = &X 
                                                        // 매개변수 size = 20
{
    printf("function_2\n");
    for (int i = 0; i < size / sizeof((*ptr)[0]); i++)  // size / sizeof((*ptr)[0]) = 20 / sizeof((*&X)[0]) = 20 / sizeof((X)[0]) →(붕괴)→ 20 / sizeof((&X[0])[0]) = 20 / sizeof(0번째 주소값을 시작으로 0번째 요소) 
                                                        //                          = 20 / sizeof(X[0]) = 20 / 4 = 5
    {
        printf("%d번째 값 %d\n", i, (*ptr)[i]);          // (*ptr)[i] = (*&X)[i] = X[0][i] →(붕괴)→ &X[0][i]
                                                        //           = 배열 0번째 주소값을 시작으로 0~4번째 요소 출력 = 배열 X 0~4번째 요소 출력 
    }
}

void function_3(int (*ptr)[10], int size)               // ptr의 자료형:  int (*)[] = 포인터 변수 자료형:  주소값 상수 + 배열 범위 초기화 = &X  
                                                        // ptr의 초기화:  인수 &X  →  매개변수 ptr = &X
                                                        // 매개변수 size = 20
{
    printf("function_3\n");
    for (int i = 0; i < size / sizeof((*ptr)[0]); i++)  // size / sizeof((*ptr)[0]) = 20 / sizeof((*&X)[0]) = 20 / sizeof((X)[0]) →(붕괴)→ 20 / sizeof((&X[0])[0]) = 20 / sizeof(0번째 주소값을 시작으로 0번째 요소) 
                                                        //                          = 20 / sizeof(X[0]) = 20 / 4 = 5
    {
        printf("%d번째 값 %d\n", i, (*ptr)[i]);          // (*ptr)[i] = (*&X)[i] = X[0][i] →(붕괴)→ &X[0][i]
                                                        //           = 배열 0번째 주소값을 시작으로 0~4번째 요소 출력 = 배열 X 0~4번째 요소 출력 
    }
}

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int(*X_ptr)[5] = &X;                         // 1)   선언   자료형: int (*)[]  포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화
                                                 // 2)   초기화 자료형: &X         포인터 변수 자료형: 주소값 상수 + 배열 범위
                                                 // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr에 초기화:    X_ptr = &X

    printf("===X Size===\n");
    printf("X size: %d\n", sizeof(X));           // sizeof(X) →(붕괴 X):  배열 X 크기 = 4 Bytes * 5개 = 20   

    printf("====================&X====================\n");
    function_1(&X, sizeof(X));
    function_2(&X, sizeof(X));
    function_3(&X, sizeof(X));

    printf("===================X_ptr==================\n");
    function_1(X_ptr, sizeof(*X_ptr));           // sizeof(*X_ptr) = sizeof(*&X) = sizeof(X) →(붕괴 X):  배열 X 크기 = 4 Bytes * 5개 = 20
    function_2(X_ptr, sizeof(*X_ptr));
    function_3(X_ptr, sizeof(*X_ptr));

    return 0;
}


```

**c\_pointer\_array\_11f.c**

```plain
#include <stdio.h>

void function_1(int array[5], int size)                // array = &X[0], size = 20 or 12 or 28
{
    printf("function_1\n");
    for (int i = 0; i < size / sizeof(array[0]); i++)  // size / sizeof(array[0]) = size / sizeof(&X[0][0]) = size / sizeof(0번째 주소값을 시작으로 0번째 요소) 
                                                       //                         = size / sizeof(X[0]) = size / 4 = 20 or 12 or 28 / 4 = 5 or 3 or 7
    {
        printf("%d번째 값 %d\n", i, array[i]);         // array[i] = &X[0][i] = 배열 X의 0번째 주소값을 시작으로 0~4 or 2 or 6번째 요소 출력 = 배열 X의 0~4 or 2 or 6번째 요소 출력
                                                       // array[i] = &Y[0][i] = 배열 Y의 0번째 주소값을 시작으로 0~4 or 2 or 6번째 요소 출력 = 배열 Y의 0~4 or 2 or 6번째 요소 출력
                                                       // array[i] = &Z[0][i] = 배열 Z의 0번째 주소값을 시작으로 0~4 or 2 or 6번째 요소 출력 = 배열 Y의 0~4 or 2 or 6번째 요소 출력      
    }
}

void function_2(int (*ptr)[5], int size)               // ptr = &X, size = 20 or 12 or 28
{
    printf("function_2\n");
    for (int i = 0; i < size / sizeof((*ptr)[0]); i++) // size / sizeof((*ptr)[0]) = size / sizeof((*&X)[0]) = size / sizeof(X[0]) →(붕괴)→ size / sizeof(&X[0][0]) = size / sizeof(0번째 주소값을 시작으로 0번째 요소) 
                                                       //                          = size / sizeof(X[0]) = size / 4 = 20 or 12 or 28 / 4 = 5 or 3 or 7 
    {
        printf("%d번째 값 %d\n", i, (*ptr)[i]);         // (*ptr)[i] = (*&X)[i] = X[0][i] →(붕괴)→ &X[0][i] = 배열 X의 0번째 주소값을 시작으로 0~4 or 2 or 6번째 요소 출력 = 배열 X의 0~4 or 2 or 6번째 요소 출력
                                                        // (*ptr)[i] = (*&Y)[i] = Y[0][i] →(붕괴)→ &Y[0][i] = 배열 Y의 0번째 주소값을 시작으로 0~4 or 2 or 6번째 요소 출력 = 배열 Y의 0~4 or 2 or 6번째 요소 출력
                                                        // (*ptr)[i] = (*&Z)[i] = Z[0][i] →(붕괴)→ &Z[0][i] = 배열 Z의 0번째 주소값을 시작으로 0~4 or 2 or 6번째 요소 출력 = 배열 Z의 0~4 or 2 or 6번째 요소 출력
    }
}

void function_3(int (*ptr)[10], int size)              // ptr = &X, size = 20 or 12 or 28           
{
    printf("function_3\n");
    for (int i = 0; i < size / sizeof((*ptr)[0]); i++) // size / sizeof((*ptr)[0]) = size / sizeof((*&X)[0]) = size / sizeof(X[0]) →(붕괴)→ size / sizeof(&X[0][0]) = size / sizeof(0번째 주소값을 시작으로 0번째 요소) 
                                                       //                          = size / sizeof(X[0]) = size / 4 = 20 or 12 or 28 / 4 = 5 or 3 or 7
    {
        printf("%d번째 값 %d\n", i, (*ptr)[i]);         // (*ptr)[i] = (*&X)[i] = X[0][i] →(붕괴)→ &X[0][i] = 배열 X의 0번째 주소값을 시작으로 0~4 or 2 or 6번째 요소 출력 = 배열 X의 0~4 or 2 or 6번째 요소 출력
                                                        // (*ptr)[i] = (*&Y)[i] = Y[0][i] →(붕괴)→ &Y[0][i] = 배열 Y의 0번째 주소값을 시작으로 0~4 or 2 or 6번째 요소 출력 = 배열 Y의 0~4 or 2 or 6번째 요소 출력
                                                        // (*ptr)[i] = (*&Z)[i] = Z[0][i] →(붕괴)→ &Z[0][i] = 배열 Z의 0번째 주소값을 시작으로 0~4 or 2 or 6번째 요소 출력 = 배열 Z의 0~4 or 2 or 6번째 요소 출력
    }
}

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int(*arr_ptr_X)[5] = &X;                //  arr_ptr_X = &X               

    int Y[3] = {1, 2, 3};
    int(*arr_ptr_Y)[3] = &Y;                //  arr_ptr_Y = &Y   

    int Z[7] = {1, 2, 3, 4, 5, 6, 7};
    int(*arr_ptr_Z)[7] = &Z[0];             // arr_ptr_Z = &X   

    printf("========X Size========\n");
    printf("X size: %d\n", sizeof(X));      // 4 Bytes * 5개 = 20
    printf("========Y Size========\n");
    printf("X size: %d\n", sizeof(Y));      // 4 Bytes * 3개 = 12
    printf("========Z Size========\n");
    printf("X size: %d\n", sizeof(Z));      // 4 Bytes * 7개 = 28    

    printf("==========&X==========\n");
    function_1(&X, sizeof(X));
    function_2(&X, sizeof(X));
    function_3(&X, sizeof(X));
    printf("==========&Y==========\n");
    function_1(&Y, sizeof(Y));
    function_2(&Y, sizeof(Y));
    function_3(&Y, sizeof(Y));
    printf("==========&Z==========\n");
    function_1(&Z, sizeof(Z));
    function_2(&Z, sizeof(Z));
    function_3(&Z, sizeof(Z));

    printf("========arr_ptr_X=======\n");
    function_1(arr_ptr_X, sizeof(*arr_ptr_X));    // sizeof(*arr_ptr_X) = sizeof(*&X) = sizeof(X) →(붕괴 X):  배열 X 크기 = 4 Bytes * 5개 = 20
    function_2(arr_ptr_X, sizeof(*arr_ptr_X));
    function_3(arr_ptr_X, sizeof(*arr_ptr_X));
    printf("========arr_ptr_Y=======\n");
    function_1(arr_ptr_Y, sizeof(*arr_ptr_Y));    // sizeof(*arr_ptr_Y) = sizeof(*&Y) = sizeof(Y) →(붕괴 X):  배열 Y 크기 = 4 Bytes * 3개 = 12
    function_2(arr_ptr_Y, sizeof(*arr_ptr_Y));
    function_3(arr_ptr_Y, sizeof(*arr_ptr_Y));
    printf("========arr_ptr_Z=======\n");
    function_1(arr_ptr_Z, sizeof(*arr_ptr_Z));    // sizeof(*arr_ptr_Z) = sizeof(*&Z) = sizeof(Z) →(붕괴 X):  배열 Z 크기 = 4 Bytes * 7개 = 28 
    function_2(arr_ptr_Z, sizeof(*arr_ptr_Z));
    function_3(arr_ptr_Z, sizeof(*arr_ptr_Z));

    return 0;
}
// 실제 배열의 크기를 사용자정의 함수에서 사용하여 배열의 요소를 출력


```

### #5 Multiple Pointer Variable 다중 포인터 변수

선언
\*++ → 한차원 ↑
사용
\*++ → 한차원 ↓

**※ Array Variable vs Pointer Variable (3) in Array**
*   &X\[0\]: 주소값 상수 = 배열 X의 0번째 주소값
*   &X : 주소값 상수 + 배열 범위 = 배열 X의 전체 주소값
★ X ➝(붕괴 O)➝ &X\[0\] 값 = &X 값

|  | Data Type | Object 목적 | Initialised Value 실제 초기화 값 |
| ---| ---| ---| --- |
| int \*\* | Pointer Variable<br>➝붕괴 (X) | 배열 전체 주소값 &X<br>∴ 자료형:<br>&X 초기화를 대상 | &X 전체 주소값을<br>주소값 상수로만 저장 = &X\[0\] |
| int (\*)\[\] | Pointer Variable<br>➝붕괴 (X) | 배열 전체 주소값 &X<br>∴ 자료형:<br>&X 초기화를 대상 | 자료형 형식 \[\]에 의해<br>주소값의 영향력 범위를 포함한<br>전체 주소값 저장 = &X |

**c\_pointer\_array\_12a.c**

```plain
#include <stdio.h>

int main()
{   
    int X[5] = {1, 2, 3, 4, 5};
   
    int(*arr_ptr_1)[5] = &X;                 // arr_ptr_1 = &X
    // * 선언시 자료형:  *++  →  한차원 ↑ 
    int *double_ptr_1 =  X;                  // double_ptr_1의 자료형 =  int *:  double_ptr_1 =  X →(붕괴 O)→ &X[0]
    int **double_ptr_2 = &X;                 // double_ptr_2의 자료형 = int **:  double_ptr_2 = &X →(주소값상수)→ &X[0]
    
    // * 사용시 자료형:  *++  →  한차원 ↓ 
    printf("%d\n", sizeof(double_ptr_2));    // 8 Bytes:    (풀이 O)   double_ptr_2의 자료형 = int **                                                 
                                             //             (풀이 X) sizeof(&X) →(주소값상수)→ sizeof(&X[0])  배열 0번째 주소값 크기 ?!?!? 
    printf("%d\n", sizeof(*double_ptr_2));   // 8 Bytes:    (풀이 O)  *double_ptr_2의 자료형 = double_ptr_2이 가르키는 값의 자료형  = int *             
                                             //             (풀이 X) sizeof(*&X[0]) = sizeof(X[0]) 배열 0번째 요소의 크기 ?!?!?  
    printf("%d\n", sizeof(**double_ptr_2));  // 4 Bytes:    (풀이 O) **double_ptr_2의 자료형 = double_ptr_2이 가르키는 값이 가르키는 값의 자료형 = int   
                                             //             (풀이 X) sizeof(*X[0])  = 배열 0번째 요소가 가르키는값의 크기 ?!?!?

    arr_ptr_1 = &X;                          
    double_ptr_2 = &X;                       // &X →(주소값상수)→ &X[0]                   
    printf("=====arr_ptr_1=====\n");
    printf("%d\n", sizeof(arr_ptr_1));       //  8 Bytes:    arr_ptr_1의 자료형 = int (*)[]  포인터 변수 자료형 = 주소값 상수 + 배열 범위 초기화 = 전체 주소값:  sizeof(전체 주소값) 
                                             //              sizeof(&X) 
    printf("%d\n", sizeof(*arr_ptr_1));      // 20 Bytes:   *arr_ptr_1의 자료형 = int []:  sizeof(int []) →(붕괴 X) = sizeof(배열) = 배열 크기
                                             //              sizeof(*&X) =  sizeof(X) →(붕괴 X)
    printf("%d\n", sizeof(**arr_ptr_1));     //  4 Bytes:  **arr_ptr_1의 자료형 = *(int []) →(붕괴 O)→ *(int *) = int:  sizeof(int) = 베열 요소 크기
                                             //              sizeof(**&X) = sizeof(*X) →(붕괴 O)→ sizeof(*&X[0]) = sizeof(X[0])
    printf("%d\n", arr_ptr_1);               //   &X
    printf("%d\n", *arr_ptr_1);              //  *&X =  X →(붕괴 O)→  &X[0]
    printf("%d\n", **arr_ptr_1);             // **&X = *X →(붕괴 O)→ *&X[0] = X[0]
    
    printf("=====double_ptr_2=====\n");
    printf("%d\n", sizeof(double_ptr_2));    // 8 Bytes:    double_ptr_2의 자료형 = int **                                                
    printf("%d\n", sizeof(*double_ptr_2));   // 8 Bytes:   *double_ptr_2의 자료형 = double_ptr_2이 가르키는 값의 자료형  = int *            
    printf("%d\n", sizeof(**double_ptr_2));  // 4 Bytes:  **double_ptr_2의 자료형 = double_ptr_2이 가르키는 값이 가르키는 값의 자료형 = int   
    printf("%d\n", double_ptr_2);            //    &X →(주소값상수)→ &X[0]
    printf("%d\n", *double_ptr_2);           //   *&X[0]  = X[0]
    // printf("%d\n", **double_ptr_2);          // **(&X[0]) = *X[0] = *1 ?????

    return 0;
}
// sizeof:  초기화값 대입하여 풀이 X   →   자료형 크기로 풀이 O  


```

**c\_pointer\_array\_12b.c**

```perl
#include <stdio.h>

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int(*arr_ptr)[5] = &X;              //    arr_ptr = &X
    int **double_ptr = &X;              // double_ptr = &X →(주소값상수)→ &X[0]
    
    printf("%d\n", &X);                  
    printf("%d\n", &X + 1);             // + 1 = + &X의 자료형이 가르키는 값의 크기 = + int (*)[]가 가르키는 값의 크기 = sizeof(int []) →(붕괴 X) = + 배열 X 크기 = 20 Bytes
                                        // ∴ &X + 1 = &X + 20 Bytes = 배열 X의 옆배열 전체 주소값
    printf("%d\n", arr_ptr + 1);        // + 1 = + arr_ptr의 자료형이 가르키는 값의 크기 = + int (*)[]가 가르키는 값의 크기 = sizeof(int []) →(붕괴 X) = + 배열 X 크기 = 20 Bytes
                                        // ∴ arr_ptr + 1 = &X + 1 = &X + 20 Bytes = 배열 X의 옆배열 전체 주소값
    printf("%d\n", double_ptr + 1);     // + 1 = + double_ptr의 자료형이 가르키는 값의 크기 = + int **가 가르키는 값의 크기 = sizeof(int *) = 8 Bytes
                                        // ∴ double_ptr + 1 = &X[0] + 8 Bytes = &X[2]
    printf("%d\n", *(double_ptr + 1));  // + 1 = + double_ptr의 자료형이 가르키는 값의 크기 = + int **가 가르키는 값의 크기 = sizeof(int *) = 8 Bytes
                                        // ∴ *(double_ptr + 1) = *(&X[2]) = X[2]
    printf("%d\n", *double_ptr + 1);    // + 1 = + *double_ptr의 자료형이 가르키는 값의 크기 = + int **가 가르키는 값의 가르키는 값의 크기 = + int *가 가르키는 값의 크기 = sizeof(int) = 4 Bytes
                                        // ∴ *double_ptr + 1 = *(&X[0]) + 1 = X[0] + 1 
    return 0;
}


```
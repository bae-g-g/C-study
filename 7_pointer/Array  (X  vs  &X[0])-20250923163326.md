# Array  (X  vs  &X[0])

# **Array 배열**

### Prerequisite Understanding
예:
int X = 5;
int \*X\_ptr;
X\_ptr = &X; // 일반 포인터 변수 = 일반 변수 주소값
\*X\_ptr = 5 = X; // 일반 변수 주소값이 가르키는/참조하는 값/변수
※ 포인터 변수 = 일반 변수의 주소값: X\_ptr = &X
int X = 5; → 변수 X의 주소값(첫번째 Byte)를 시작으로 정수 5 초기화
★ X\_ptr = 일반 변수 X의 주소값 = &X
↓ 한차원 아래
\*X\_ptr = 일반 변수 X의 주소값이 가르키는/참조하는 값/변수 = 5 = X
★ X\_ptr(= &X)의 자료형 = 일반 변수 X의 주소값의 자료형 = int \*
int 포인터 (변수)
↓ 한차원 아래
\*X\_ptr의 자료형 = 일반 변수 X의 주소값이 가르키는/참조하는 값/변수의 자료형 = int
int 정수

Ref) 포인터 변수(= 주소값)보다
\*포인터 변수(= 주소값이 가르키는/참조하는 값/변수)는 한차원 ↓
\= 변수의 주소값 아래에 변수값이 초기화

예:
int Y\[5\] = {1, 2, 3, 4, 5};
int \*Y\_ptr;
Y\_ptr = Y; // Y\_ptr = &Y\[0\]; 배열 포인터 변수 = 배열 변수 Y →(붕괴)→ 배열 Y 0번째 주소값
\*Y\_ptr = 1; // 배열 Y의 0번째 주소값(= 배열 변수 Y)가 가르키는/참조하는 값/변수
※ 배열 포인터 변수 = 배열 변수 →(붕괴)→ 배열 0번째 주소값: Y\_ptr = Y →(붕괴)→ &Y\[0\]
int Y\[5\] = {1, 2, 3, 4, 5}; → 배열 Y의 0번째 주소값(첫번째 Byte)를 시작으로 정수 1~5 초기화
i.e) 배열 변수 Y →(붕괴)→ 배열의 0번째 주소값 &Y\[0\] = 배열 포인터 변수 Y\_ptr
∴ int Y\[5\];
scanf("%s", &Y); // scanf("%s", Y); Y →(붕괴)→ &Y\[0\] i.e. Y 값 = Y 배열 0번째 주소값
//  &Y ≒ Y →(붕괴)→ &Y\[0\]
// **∵** &Y = Y = &Y\[0\] 값은 동일 But 의미는 상이
`scanf %s + &변수` → 변수의 주소값(0번째 주소값 = 첫번째 Byte)을 시작으로 초기화
&Y:
배열 Y의 전체 주소값 첫번째 Byte를 시작으로 초기화
Y →(붕괴)→ &Y\[0\]:
배열 Y의 0번째 주소값 첫번째 Byte를 시작으로 초기화
★ Y\_ptr = 배열 변수 Y →(붕괴)→ 배열 Y의 0번째 주소값 &Y\[0\]
↓ 한차원 아래
\*Y\_ptr = 배열 Y의 0번째 주소값(= 배열 변수 Y)이 가르키는/참조하는 값/변수 = Y\[0\] = 1
★ Y\_ptr(= Y →(붕괴)→ &Y\[0\])의 자료형 = 배열 변수→(붕괴)→배열 0번째 주소값의 자료형
\= int \*
int 포인터 (배열)
Ref) int Y\[5\] = {1, 2, 3, 4, 5};
Y 자료형 = int \[\] →(붕괴)→ &Y\[0\] 자료형 = int \*= int \*
int 배열 int 포인터 (배열)

↓ 한차원 아래
\*Y\_ptr = 배열 Y의 0번째 주소값이 가르키는/참조하는 값/변수의 자료형 = int
int 정수
Ref) 배열 포인터 변수(= 배열의 0번째 주소값)보다
\*배열 포인터 변수(= 배열의 0번째 주소값이 가르키는/참조하는 값)는 한차원 ↓
\= 배열 0번째 주소값 아래에 변수값이 초기화

예:
int Z\[3\] = {1, 2, 3};
int(\*Z\_ptr)\[3\];
Z\_ptr = &Z //  배열 전체 포인터 변수 = 배열 전체 Z의 주소값
\*Z\_ptr = Z →(붕괴)→ &Z\[0\] // 배열 전체 Z의 주소값이 가르키는/참조하는 값/변수
※ 배열 전체 포인터 변수 = 배열(전체) 주소값 : &Z
int Z\[3\] = {1, 2, 3}; → 배열 전체 Z의 주소값(첫번째 Byte)를 시작으로 정수 1~3 초기화
★ Z\_ptr = 배열 전체 Z의 주소값 = &Z
↓ 한차원 아래
\*Z\_ptr = 배열 전체 Z의 주소값이 가르키는/참조하는 값/변수
\= 배열 변수 Z →(붕괴)→ 배열 전체 Z의 0번째 주소값
\= &Z\[0\]
★ Z\_ptr(= &Z)의 자료형 = 배열 전체 Z의 주소값의 자료형 = int (\*) \[\]
int 포인터 배열 전체
↓ 한차원 아래
\*Z\_ptr의 자료형 = 배열 전체 Z의 주소값이 가르키는/참조하는 값/변수의 자료형
\= int \[\] →(붕괴)→ int \*
int 배열 int 포인터 (배열)

Ref) 배열 전체 포인터 변수(= 배열 전체의 주소값)보다
\*배열 전체 포인터 변수(= 배열 전체의 주소값이 가르키는/참조하는 값)는 한차원 ↓
\= 배열 전체의 주소값 아래에 배열 변수 →(붕괴)→ 배열의 0번째 주소값이 초기화
※※※
배열 전체 포인터 변수 Z\_ptr = 배열 전체 Z의 주소값 &Z
≒ 배열 변수 Z →(붕괴)→ 배열 Z의 0번째 주소값 Z →(붕괴)→ &Z\[0\]
*   값 Value는 서로 동일
*   의미 Mean은 서로 유사
★ &X : 주소값 상수 + 배열 범위 = 배열 X의 전체 주소값
★ &X\[0\]: 주소값 상수 = 배열 X의 0번째 주소값

### &X\[0\] vs X vs &X

| int X = 5;<br>int \*X\_ptr;<br>X\_ptr = &X; // 일반 포인터 변수 = 일반 변수 주소값<br>\*X\_ptr = 5 = X; // 일반 변수 주소값이 가르키는/참조하는 값/변수 |
| --- |
| X\_ptr | &X | int \* |
| ↓ 한차원 아래 |
| \*X\_ptr | 5 = X | int |
|  |
| int Y\[5\] = {1, 2, 3, 4, 5};<br>int(\*A\_ptr)\[5\];<br>A\_ptr = &Y; // 배열 전체 포인터 변수 = 배열 전체 Y의 주소값<br>\*A\_ptr = Y →(붕괴)→ &Y\[0\]; // 배열 전체 Y의 주소값이 가르키는/참조하는 값/변수<br><br>int \*B\_ptr;<br>B\_ptr = &Y\[0\]; // B\_ptr = Y; 배열 포인터 변수 = 배열 Y의 0번째 주소값 = 배열 변수 Y<br>\*B\_ptr = 1; // 배열 Y의 0번째 주소값(= 배열 변수 Y)가 가르키는/참조하는 값/변수<br>\*(\*A\_ptr) = 1; |
| A\_ptr | &Y | int (\*)\[ \] |
| ↓ 한차원 아래 |  |  |
| \*A\_ptr = B\_ptr | Y →(붕괴)→ &Y\[0\] | int \[ \] →(붕괴)→ int \* |
| ↓ 한차원 아래 |
| \*B\_ptr = \*(\*A\_ptr) | Y\[0\] = 1 | int |

**c\_pointer\_array\_0a.c**

```cpp
#include <stdio.h>

int main()
{   
    // Reference 1:  일반 변수
    int D = 5;
    printf(" Pre_D = %d\n", D);
    int *D_ptr = &D;
    *D_ptr = 10;
    printf("Post_D = %d\n", D);
    
    // Reference 2:  배열 변수
    int B[3] = {4, 5, 6};
    int C[3] = {7, 8, 9}; 
    B = C;                 // 배열 B = 배열 C  →(붕괴)→  배열 B의 0번째 주소값(&B[0])을 배열 C의 0번째 주소값(&C[0])로 변경" 한다는 의미
                           // 안되는 이유 1)  배열은 배열전체 복사 불가:  배열요소 각각 변경 要
                           // 안되는 이유 2)  배열은 포인터로 붕괴 → 처음 선언한 배열의 주소값을 변경하려는 동작(같은 주소값 or 다른 주소값) 불가
    
    // Application:  배열 변수
    int A[3] = {1, 2, 3};
    int(*A_ptr)[3];
    A_ptr = &A; 
    *A_ptr = A;            // 배열 A = 배열 A   →(붕괴)→  배열 A의 0번째 주소값(&A[0])을 배열 A의 0번째 주소값(&A[0] = A)로 변경 
                           // 참고 2: 안되는 이유 1) + 안되는 이유 2)
    return 0;
}
         
```

**c\_pointer\_array\_0b.c**

```perl
#include <stdio.h>

int main()
{
    int X[3] = {1, 2, 3};

    int(*arr_ptr_1)[3];
    arr_ptr_1 = &X;

    int *arr_ptr_2; // 선언   자료형:  int *  포인터 변수 자료형
    arr_ptr_2= X;   // 초기화 자료형:  X →(붕괴)→ &X[0]  포인터 변수 자료형

    printf("%d\n", &X);
    printf("%d\n", arr_ptr_1);
    printf("%d\n", *&X);
    printf("%d\n", *arr_ptr_1);
    printf("%d  %d  %d\n", *&(X[0]), *&(X[1]), *&(X[2])); // *&X[0], *&X[1], *&X[2]

    printf("=======\n");

    printf("%d\n", X);
    printf("%d\n", &X[0]);
    printf("%d\n", arr_ptr_2);
    printf("%d\n", *X);
    printf("%d\n", *&X[0]);
    printf("%d\n", *arr_ptr_2);
    // printf("%d  %d  %d\n", **&(X[0]), **&(X[1]), **&(X[2]));

    return 0;
}


```

* * *

## **X vs &X\[0\]**

### #1 Declaration/Initialisation/Use 선언/초기화/사용
#### #1-1 배열 포인터 변수 선언 및 초기화
`자료형 *변수`
자료형 포인터+배열 포인터 변수
→ 배열 포인터 변수는 주소값(배열 0번째 주소값의 첫번째 Byte) 초기화 역할
→ 배열 포인터 변수는 주소값의 영향력 범위 지정 역할
\= 주소값이 가르키는/참조하는 값/변수의 자료형의 종류/크기 지정 역할
∴ `자료형`: 주소값이 가르키는값/참조하는 값/변수의 자료형 + `*`
예:
int \*, char \*, float \*
#### #1-2 포인터와 배열 포인터 변수 사용
`*변수`
포인터+배열 포인터 변수
→ 배열 포인터 변수에 초기화된 주소값이 가르키는/참조하는 값/변수
→ 포인터+배열 포인터 변수의 반환값(Return 값)
\= 배열 0번째 주소값이 가르키는/참조하는 값/변수
\= 배열 0번째 요소
∴ `자료형`: 주소값이 가르키는값/참조하는 값/변수의 자료형
예:
int, char, float

### ★ Array to Pointer Decay 배열 '변수' →(붕괴)→ 배열 '포인터 변수'
배열 변수는 대부분의 경우 포인터 변수로 붕괴 (예외 2가지 Cases 下 #2-1 #2-2)
**c\_pointer\_array\_1.c**

```perl
#include <stdio.h>

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int *X_ptr; // 선언   자료형: int *  포인터 변수 자료형

    X_ptr = X;  // 초기화 자료형: X →(붕괴)→ &X[0]  포인터 변수 자료형 
    
    printf("X_ptr: %d\n", X_ptr);
    printf("&X[0]: %d\n", &X[0]);
    printf("    X: %d\n", X);

    return 0;
}


```

### #2 Array to Pointer Decay X 배열 변수→배열 포인터 변수 붕괴 X: (不) X→&X\[0\]
C99(C Language Compiler – Year 99 Version) 이후 Version
배열 변수 → 배열 포인터 변수 붕괴 X Case 2가지

#### #2-1 &Array Variable &배열 변수

**c\_pointer\_array\_2a.c**

```cpp
#include <stdio.h>

int main()
{
    int X[5] = {1, 2, 3, 4, 5};

    printf("&X: %d\n", &X);               // 의미 Mean:  배열 0번째 주소값(= &X[0]) X  → 배열 전체 주소값 O
                                          //  값 Value:  배열 0번째 주소값 = 배열 전체  주소값
    // printf("&&X[0]: %d\n", &(&X[0]));     // 배열의 [0]번째 주소값의 주소값 ?!?! → Compiling Error

    return 0;
}


```

&X = 배열 전체 주소값
if ⇒ 배열 변수 → 포인터 변수 붕괴 O
&X = &(&X\[0\]) // 배열 0번째 주소값의 주소값 → 배열 0번째 주소값의 주소값 無

**c\_pointer\_array\_2b.c**

```perl
#include <stdio.h>

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int *X_ptr; // 선언   자료형: int *  포인터 변수 자료형

    X_ptr = X;  // 초기화 자료형: X →(붕괴)→ &X[0]  포인터 변수 자료형 

    printf("    &X: %d\n", &X);
    printf(" &X[0]: %d\n", &X[0]);
    printf(" X_ptr: %d\n", X_ptr);
    printf("\n&X_ptr: %d\n", &X_ptr);   // X_ptr의 주소값

    return 0;
}


```

&X = 배열 전체 주소값
if ⇒ 배열 변수 → 포인터 변수 붕괴 O
X = &X\[0\]
X\_ptr = X = &X\[0\]
&X\_ptr = &X = &(&X\[0\]) // 배열 0번째 주소값의 주소값 → 배열 0번째 주소값의 주소값 無 ?!?!?
∴ &X\_ptr = X\_ptr(선언한) 배열 포인터 변수(자체)의 주소값
예:
int X = 10;
※ int X; 선언시
X의 주소값 有 & 상수 10 '자체'의 주소값 無
\= 상수 10이 초기화된 메모리박스 주소값 有 = X의 주소값
int X\[10\];
int \*X\_ptr = &X\[0\];
※ int \*X\_ptr; 선언시
X\_ptr의 주소값 有 & 상수 &X\[0\] '자체'의 주소값 無
\= 상수 &X\[0\]이 초기화된 메모리박스 주소값 有 = X\_ptr의 주소값
∴ &X\[0\]의 주소값 = &(&X\[0\]) → &X\[0\]의 주소값 無

![](https://t9003081320.p.clickup-attachments.com/t9003081320/073f8e29-309a-4892-96ac-f481c1994e73/1.png)
배열 전체의 주소값 &X ≒ 배열 0번째 주소값 &X\[0\]
\= &X ≒ &X\[0\] = 0xFFFFFFFF FFFF0001
배열 포인터 변수 주소값 = 배열 전체의 주소값/배열 0번째 주소값이 초기화된 포인터 변수 주소값
\= &X\_ptr = 0xFFFFFFFF FFFFFFF0

#### #2-2 sizeof(Array Variable) sizeof(배열 변수)
배열 변수 크기 = (배열 요소의 자료형 Bytes) X (배열 크기)
배열 포인터 변수 크기 = 8 Bytes

**c\_pointer\_array\_3.c**

```perl
#include <stdio.h>

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int *X_ptr; // 선언   자료형: int *  포인터 변수 자료형

    X_ptr = X;  // 초기화 자료형: X →(붕괴)→ &X[0]  포인터 변수 자료형 

    printf("    X의 size: %d\n", sizeof(X));
    printf("\n&X[0]의 size: %d\n", sizeof(&X[0]));
    printf("X_ptr의 size: %d\n", sizeof(X_ptr));

    return 0;
}


```

sizeof(X) = int 4 Bytes X 5개 = 20 Bytes
if ⇒ 배열 변수 → 포인터 변수 붕괴 O
X = &X\[0\]
X\_ptr = X = &X\[0\]
sizeof(X) = sizeof(&X\[0\]) = 0번째 요소 주소값 크기 = 8 Bytes
sizeof(X\_ptr) = 배열 포인터 변수 크기 = 8 Bytes
∴ sizeof(X) ≠ sizeof(&X\[0\]) = sizeof(X\_ptr)
∴ 배열 변수 → 포인터 변수 붕괴 X

### #3 Array to Pointer Decay O 배열 변수→배열 포인터 변수 붕괴 O: (能) X→&X\[0\]
C99(C Language Compiler – Year 99 Version) 이후 Version
배열 변수 → 배열 포인터 변수 붕괴 O Case n가지 (예외 Cases 2가지 上 제외하고 대부분의 Cases)

#### #3-1 Address 주소값
배열 변수 = 배열 포인터 변수
X\_ptr
X = &X\[0\]

**c\_pointer\_array\_4.c**

```perl
#include <stdio.h>

int main()
{
    int X[5];
    int *X_ptr; // 선언   자료형: int *  포인터 변수 자료형

    X_ptr = X;  // 초기화 자료형: X →(붕괴)→ &X[0]  포인터 변수 자료형    
    
    printf("X_ptr: %d\n", X_ptr);
    printf("&X[0]: %d\n", &X[0]);
    printf("    X: %d\n", X);

    return 0;
}


```

※ X\_ptr = X →(붕괴)→ &X\[0\]

#### #3-2 ± Operation to Pre/Post Address Access ± 연산
배열 변수 연산 = 배열 포인터 변수 연산
X\_ptr ± n
X ± n = &X\[0\] ± n

#### 개념 이용)
사칙연산 (+ – \* /)
연산 객체 "**단위"**만큼 + – \* /
예:
2 \+ 3 = 5
*   2: 10진수
*   \+ 3: 10진수 단위에서 3만큼 증가
*   \= 5: 10진수 2에 10진수 단위로 3만큼 증가한 값

∴

| ※ "연산 단위가" 무엇인가? |
| --- |
| ※ "연산 단위"는 "± int 정수"를 의미 |
| ※ "± int 정수"의 의미(크기)가 무엇인가? |
| 예: ± 1 에서 "1"이 의미(크기)가 무엇인가? |

i.e.
![](https://t9003081320.p.clickup-attachments.com/t9003081320/4bd3c485-3abf-4031-b1fd-2ddab0fc329a/%EA%B7%B8%EB%A6%BC5.png)

포인터 변수 +1 = 포인터 변수가 가르키는 값의 자료형의 크기만큼 +
포인터 변수 \-1 = 포인터 변수가 가르키는 값의 자료형의 크기만큼 -
⇒
배열 포인터 변수 +1 = 배열 포인터 변수가 가르키는 값의 자료형의 크기만큼 +
\= 배열 주소값이 가르키는 값 자료형의 크기만큼 +
\= int/float: + 4 or char: + 1
배열 포인터 변수 +1 = 배열 포인터 변수가 가르키는 값의 자료형의 크기만큼 -
\= 배열 주소값이 가르키는 값 자료형의 크기만큼 -
\= int/float: - 4 or char: - 1
예:
int X\[5\] = {1, 2, 3, 4, 5};
int \*X\_ptr = &X\[0\] // X ➝(붕괴)➝&X\[0\]
⇒
포인터 변수 + 1
X\_Ptr + 1
&X\[0\] + 1
배열 0번째 주소값 + 자기 자신(의 메모리박스 크기)
배열 0번째 주소값 + 배열 0번째 "주소값에 해당하는" 메모리박스 크기(= 아래에 저장된 요소의 크기)
&X\[0\] + 4 // sizeof(X\[0\])

#### 자료형 이용)
※ 배열 포인터 변수(= 0번째 주소값)의 크기
\= 8 Bytes (64 Bits OS)
★ 0번째 주소값이 초기화된 메모리박스(자료형) 크기 = 8 Bytes

※ 배열 포인터 변수(= 0번째 주소값)의 연산(예: ± 1)
\= 0번째 주소값 ± 1
\= 0번째 주소값
± 0번째 주소값이 가르키는/참조하는 값/변수의 메모리박스(자료형) 크기
(int/float ±4 or char ±1)
\= 0번째 주소값
± 배열 포인터 변수의 자료형이 가르키는/참조하는 값의 크기
(int \* float \* char \*) (int/float ±4 or char ±1)
↓ 한차원 아래
※ \*배열 포인터 변수(= 0번째 주소값이 가르키는/참조하는 값/변수)의 연산(예: ± 1)
\= 0번째 주소값이 가르키는/참조하는 값 ± 1

※※※
배열 포인터 변수 ± int n
\= 배열 0번째 주소값 ± (0번째 주소값이 가르키는/참조하는 값/변수의 메모리박스 크기 x n)
\= 배열 0번째 주소값 ± (배열 포인터 변수 자료형이 가르키는/참조하는 값/변수의 크기 x n)
(int \* float \* char \*) (int/float ±4 or char ±1)
i.e. 배열 0번째 주소값 ± (배열요소 자료형 크기 x n)
↓ 한차원 아래
\*배열 포인터 변수 ± int n
\= 배열 0번째 요소 ± int n
####   

**c\_pointer\_array\_5.c**

```perl
#include <stdio.h>

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int *X_ptr; // 선언   자료형: int *  포인터 변수 자료형

    X_ptr = X;  // 초기화 자료형: X →(붕괴)→ &X[0]  포인터 변수 자료형   
    
    printf("         *X_ptr: %d\n", *X_ptr);
    printf("       *(&X[0]): %d\n", *(&X[0]));
    printf("             *X: %d\n", *X);

    printf("   *(X_ptr + 1): %d\n", *(X_ptr + 1));
    printf("   *(&X[0] + 1): %d\n", *(&X[0] + 1));
    printf("       *(X + 1): %d\n", *(X + 1));

    printf("  (*X_ptr) + 10: %d\n", (*X_ptr) + 10);
    printf("(*(&X[0])) + 10: %d\n", (*(&X[0])) + 10);
    printf("      (*X) + 10: %d\n", (*X) + 10);

    return 0;
}


```

#### #3-3 Pointer Variable & Array Variable Use: General 포인터 변수 & 배열 변수 사용
#### #3-3A General 일반
배열 포인터 변수 = 배열 변수
X\_ptr
&X\[0\] X

**c\_pointer\_array\_6a.c**

```cpp
#include <stdio.h>

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int *X_ptr; // 선언   자료형: int *  포인터 변수 자료형

    X_ptr = X;  // 초기화 자료형: X →(붕괴)→ &X[0]  포인터 변수 자료형 

    X_ptr[2] = 97;  
    (&X[0])[3] = 98;
    X[4] = 99;
    // X_ptr = &X[0] = X

    for (int i = 0; i < 5; i++)
    {
        printf("X_ptr[%d]: %d\n", i, X_ptr[i]);
    }

    return 0;
}


```

※ X\_ptr = X →(붕괴)→ &X\[0\]

#### #3-3B Function 함수
배열 포인터 변수 = 배열 변수
X\_ptr
&X\[0\] X

배열 X = &X\[0\]

|  | 변수 int char float | 배열 X = &X\[0\] |
| ---| ---| --- |
| 사용자정의 함수 | 매개변수<br>int \* A<br>A = &X<br><br><br><br>매개변수<br>int \* A\_ptr\_1<br>A\_ptr\_1 = X\_ptr\_1<br><br>※ A = A\_ptr\_1<br>※ 자료형<br>int \* | 매개변수<br>int A\[5\]<br>A ➝(붕괴)➝ &A\[0\]<br>X ➝(붕괴)➝ &X\[0\]<br><br><br>매개변수<br>int \* A\_ptr\_2<br>A\_ptr\_2 = \_ptr\_2<br><br>※ A = A\_ptr\_2<br>※ 자료형<br>int \* (배열) |
| ↑ | ↑ | ↑ |
| 메인 함수 | 인수<br>&X = X\_ptr\_1 | 인수<br>X ➝(붕괴)➝ &X\[0\] = X\_ptr\_2 |

※ 사용자정의 함수에서도 매개변수가 배열일때 포인터 변수로 붕괴
∵ Effective Compiling
메인함수의 배열 X(요소)를 사용자정의 함수로 모두 전달(매개변수)
VS
메인함수의 배열 X(요소) ➝(붕괴)➝ &X\[0\]를 사용자정의 함수로 0번째 주소값만 전달(매개변수)

**※ Array Variable vs Pointer Variable (1) in Array**

| Array Variable | int \[\] | int 배열 |
| ---| ---| --- |
| 붕괴 (O) ↓ |
| Pointer Variable | int \* | int 포인터 (배열) |
|  |
| Pointer Variable | int (\*)\[\] | int 포인터 배열 전체 |
| 붕괴 (X) ↓ |
|  |
| Array Variable | int \*\[\]<br>int \*를 \[\]개 있는 배열 | int 포인터 배열 |
| 붕괴 (O) ↓ |
| Pointer Variable | int \*\* | int 이중 포인터 |

**※ Array Variable vs Pointer Variable (2) in Array**

| Array Variable |  | Pointer Variable |  |
| ---| ---| ---| --- |
| int \[\] | ➝붕괴 (O)➝ | int \* |  |
| \- |  | int (\*)\[\] | ➝붕괴 (X) |
| int \*\[\]<br>int \*를 \[\]개 있는 배열 | ➝붕괴 (O)➝ | int \*\* |  |

**※ Array Variable vs Pointer Variable (3) in Array**
*   &X\[0\]: 주소값 상수 = 배열 X의 0번째 주소값
*   &X : 주소값 상수 + 배열 범위 = 배열 X의 전체 주소값
★ X ➝(붕괴 O)➝ &X\[0\] 값 = &X 값

|  | Data Type | Object | Initialised Value |
| ---| ---| ---| --- |
| int \*\* | Pointer Variable<br>➝붕괴 (X) | 배열 전체 주소값 &X | 주소값 상수만 저장 = &X\[0\] |
| int (\*)\[\] | Pointer Variable<br>➝붕괴 (X) | 배열 전체 주소값 &X | 자료형 형식 \[\]에 의해<br>범위를 포함한 주소값 저장 = &X |

**c\_pointer\_array\_6b\_ref\_1.c**
※ int (\*)\[\] & int \*\*

```plain
#include <stdio.h>

int main()
{   
    int X[5] = {1, 2, 3, 4, 5};
   
    int(*arr_ptr_1)[5] = &X;                 // arr_ptr_1의 자료형: int (*)[] (int 포인터 배열 전체)  
                                             //                    →  int (*)[] = 포인터 변수 자료형 →(붕괴 X)
                                             //                    ∴  포인터 변수 자료형
                                             // arr_ptr_1의 초기화:  선언한 자료형에 영향 받음
                                             //                     Ref) char X = 10;
                                             //                          printf("%d\n", sizeof(X));   X의 크기는 초기화값 int 10의 크기 X   메모리박스 char A 크기 O
                                             //                          printf("%d %c\n", X);        int 00000000 0000000 0000000 00001010 (4 Bytes) →(형변환 O)→ char 00001010 (1 Byte) 
                                             //                     ∴ int (*)[]: 배열 전체 주소값(&X)을 초기화 위한 자료형 →(자료형: 포인터 변수형 + "[]")→ 주소값 상수 + "배열 범위(&X)" = &X
                                             //                          Ref)  &X[0] 자료형:  주소값 상수
                                             //                                &X    자료형:  주소값 상수 + 배열 범위
                                             //                          i.e.  int (*[]) = &X 초기화
                                             //                     ∴ arr_ptr_1 = &X 
    // * 선언시 자료형:  *++  →  한차원 ↑ 
    int *double_ptr_1 =  X;                  //  double_ptr_1의 자료형:  int * = 포인터 변수 자료형 O  배열 변수 자료형  X
                                             //                          ∴ 포인터 변수 자료형 →(붕괴 X)
                                             //  double_ptr_1의 초기화:  선언한 자료형에 영향 받음
                                             //                          Ref) char X = 10;
                                             //                               printf("%d\n", sizeof(X));   X의 크기는 초기화값 int 10의 크기 X   메모리박스 char A 크기 O
                                             //                               printf("%d %c\n", X);        int 00000000 0000000 0000000 00001010 (4 Bytes) →(형변환 O)→ char 00001010 (1 Byte) 
                                             //                          ∴ double_ptr_1 = X →(붕괴 O)→ &X[0]
                                             //                          ⇒ double_ptr_1 = &X[0]     
    int **double_ptr_2 = &X;                 //  double_ptr_2의 자료형:  int ** = 포인터 변수 자료형 O  배열 변수 자료형  X
                                             //                          ∴ 포인터 변수 자료형 →(붕괴 X)
                                             //  double_ptr_2의 초기화:  선언한 자료형에 영향 받음
                                             //                          Ref) char X = 10;
                                             //                               printf("%d\n", sizeof(X));   X의 크기는 초기화값 int 10의 크기 X   메모리박스 char A 크기 O
                                             //                               printf("%d %c\n", X);        int 00000000 0000000 0000000 00001010 (4 Bytes) →(형변환 O)→ char 00001010 (1 Byte) 
                                             //                          ∴ int *:  int [] (int 배열)  →(붕괴 O)→  int *   =  배열  →(붕괴 O)→ 배열 0번째 주소값(= 포인터 변수 형식) 초기화를 위한 자료형 (General Use)
                                             //                            의 한차원 ↑
                                             //                            int **: 배열 전체 주소값(&X)을 초기화 위한 자료형 →(자료형: 포인터 변수형)→ 주소값 상수(&X[0])만 저장
                                             //                                    Ref)  &X[0] 자료형:  주소값 상수
                                             //                                          &X    자료형:  주소값 상수 + 배열 범위
                                             //                                          i.e.  int ** = &X[0] 초기화
                                             //                          ∴ double_ptr_2 = &X →(형변환)→ 개념 &(&X[0]) ⇒ 실제 &X[0] 
                                             //                                      Ref) &X       자료형 = 주소값 상수 + 범위
                                             //                                           &(&X[0]) 자료형 = 주소값의 주소값 (실존 X)
                                             //                                           &X[0]    자료형 = 주소값 상수     (실존 O)    
    // * 사용시 자료형:  *++  →  한차원 ↓ 
    printf("%d\n", sizeof(double_ptr_2));    // 8 Bytes:    double_ptr_2의 자료형 = int **                                                 (배열 전체 주소값)
    printf("%d\n", sizeof(*double_ptr_2));   // 8 Bytes:   *double_ptr_2의 자료형 = double_ptr_2이 가르키는 값의 자료형  = int *             (배열 주소값 →(붕괴 0)→ 배열 0번째 주소값)
    printf("%d\n", sizeof(**double_ptr_2));  // 4 Bytes:  **double_ptr_2의 자료형 = double_ptr_2이 가르키는 값이 가르키는 값의 자료형 = int   (배열 0번째 요소)

    arr_ptr_1 = &X;                          // 07번째줄:  arr_ptr_1 = &X  
    double_ptr_2 = &X;                       // 30번째줄:  double_ptr_2 = &X[0]
                                             // Ref)
                                             // 1) int []   →(붕괴 O)→  int *     int X[5]에서 X  →(붕괴)→ int *X_ptr = &X[0]에서 &X[0]  
                                             //   배열 변수  →(붕괴 O)→  포인터 변수 
                                             // 2) int * []  →(붕괴 O)→  int **                                                 
                                             //    배열 변수  →(붕괴 O)→  이중 포인터 변수
                                             // →  2)에서 int * [] 이 가르키는 값의 자료형의 크기 = 한차원 아래인 1)에서 int [] 크기  =  배열 X 크기
                                             // →  2)에서 int **   이 가르키는 값의 자료형의 크기 = 한차원 아래인 1)에서 int * 크기   =  배열 포인터 변수(X_ptr = X →(붕괴)→ &X[0]) 크기                                       
    printf("=====07번째줄 선언 관련=====\n");
                                             // Approach 1:   정석 X
    printf("%d\n", sizeof(arr_ptr_1));       // sizeof(&X)
    printf("%d\n", sizeof(*arr_ptr_1));      // sizeof(X)  →(붕괴 X)→ sizeof(&X[0])    ∵  sizeof 함수에서 배열 변수 X가 포인터 변수 &X[0]으로 붕괴되지 않는 예외 Case 적용됨 
    printf("%d\n", sizeof(**arr_ptr_1));     // sizeof(*X) →(붕괴 O)→ sizeof(*(&X[0])) ∵  X에 sizeof 함수를 사용 X  →  *X = X가 가르키는 값 →(붕괴)→ &X[0]이 가르키는 값에 sizeof 함수를 사용 O
                                             //                                                                                     i.e. X   →(붕괴 O)→  &X[0] 후 sizeof 함수 사용 O
                                             // Approach 2:   정석 O
                                             // 변수의 초기화값으로 sizeof 연산하기보다, 변수의 자료형으로 연산함이 정석 
                                             //   sizeof(arr_ptr_1) =   arr_ptr_1의 자료형의 크기 =  int (*)[]의 크기 = 배열 전체 포인터 변수의 크기 = 8 Bytes
                                             //  sizeof(*arr_ptr_1) =  *arr_ptr_1의 자료형의 크기 =     int []의 크기 = 배열의 크기 = 배열 요소의 크기 x 배열 요소의 갯수 = 4 Bytes x 5개 = 20 Bytes
                                             //                                                        ∵  sizeof 함수에서 배열 int []가 포인터 변수로 붕괴 되지 않는 예외 Case 적용됨
                                             //                                                        i.e. int [] →(붕괴 X)→ int * = X →(붕괴 X)→ &X[0]
                                             //  sizeof(**arr_ptr_1) = **arr_ptr_1의 자료형의 크기 =       int의 크기 = 4 Bytes
                                             //                                                           ∵  sizeof 함수가 배열 int []가 가르키는 값 *(int [])을 한후 적용
                                             //                                                           i.e. *(int []) →(붕괴 0)→ *(int *) = *(X) →(붕괴 O)→ *(&X[0])
    
    printf("=====30번째줄 선언 관련=====\n");
                                             // Approach 1:   정석 X
    printf("%d\n", sizeof(double_ptr_2));    // sizeof(&X)     
    printf("%d\n", sizeof(*double_ptr_2));   // sizeof(X)  →(붕괴 O)→ sizeof(&X[0])    ∵  배열 포인터 변수 선언에서만  sizeof 함수에서 배열 변수가 포인터 변수로 붕괴되지 않는 예외 Case 적용됨 
    printf("%d\n", sizeof(**double_ptr_2));  // sizeof(*(&X[0]))
                                             // Approach 2:   정석 O
                                             // 변수의 초기화값으로 sizeof 연산하기보다, 변수의 자료형으로 연산함이 정석 
                                             //   sizeof(double_ptr_2) =   double_ptr_2의 자료형의 크기 =  int **의 크기 = (배열 전체) 이중 포인터 변수의 크기 = 8 Bytes
                                             //  sizeof(*double_ptr_2) =  *double_ptr_2의 자료형의 크기 =   int *의 크기 = (배열) 포인터 변수 크기 = 8 Bytes 
                                             // sizeof(**double_ptr_2) = **double_ptr_2의 자료형의 크기 =     int의 크기 = 4 Bytes

    return 0;
}


```

**c\_pointer\_array\_6b\_ref\_2.c**
※ int \* \[\] (int 포인터 배열) →(붕괴 O)→ int \*\* (int 이중 포인터)

```plain
// 사용자 정의 함수에서 배열 변수 →(붕괴 O)→ 포인터 변수 
#include <stdio.h>

void function_1(int A[5])          // A의 자료형:  int [] (int 배열) →(붕괴 O)→ int * (int 포인터):  int A[5] →(붕괴 O)→ int *
                                   //             →  int [] = 배열 변수 자료형  →(붕괴 O)→ int * = 포인터 변수 자료형 
                                   // A의 초기화:  선언한 자료형에 영향 받음
                                   //             Ref) char X = 10;
                                   //                  printf("%d\n", sizeof(X));   X의 크기는 초기화값 int 10의 크기 X   메모리박스 char A 크기 O
                                   //                  printf("%d %c\n", X);        int 00000000 0000000 0000000 00001010 (4 Bytes) →(형변환 O)→ char 00001010 (1 Byte) 
                                   //             ∴ int *: 배열 →(붕괴 O)→ 포인터 변수
                                   //                      i.e.  int * = &X[0] 초기화
                                   //             ∴ A = &X[0]                     
                                   //             ⇒    인수 &X[0]  →(초기화)→  매개변수 A = &X[0]      
                                   // 선언 자료형 (int * 포인터 변수형: 주소값 상수 초기화) = 초기화 자료형 (&X[0] 포인터 변수형: 주소값 상수)  ∴ 초기화시 선언 자료형에 맞춰 형변환 필요 X  
{

    printf("%d\n", sizeof(A));     //  sizeof(A) =  A의 자료형의 크기 = int *의 크기 = 8 Bytes
    printf("%d\n", sizeof(*A));    // sizeof(*A) = *A의 자료형의 크기 =  int 의 크기 = 4 Bytes

    printf("%d\n", A);             // A = &X[0]
    printf("%d\n", *A);            // A = *(&X[0]) = 1

    printf("%d\n", *(A + 1));      // *(A + 1) = *(A + A의 자료형이 가르키는 값의 크기) = *(A + int *가 가르키는 값의 크기) = *(A + 4 Bytes) = *(&X[0] + 4 Bytes) = *(&X[1]) = 2
    printf("%d\n", *A + 1);        // *A + *A의 자료형이 가르키는 값의 크기 = *A + int *가 가르키는 값의 자료형이 가르키는 값의 크기 = *A + int가 가르키는 값의 크기 = *(&X[0]) + 1 = 1 + 1 = 2 
}
// 언제 배열 변수가 포인터 변수로 붕괴 O되는지? 언제 sizeof() 함수를 사용하는지? 주목

// int * [] (int 포인터 배열) →(붕괴 O)→ int ** (int 이중 포인터) 
void function_2(int *A[5])         // Approach 1:   정석 X
                                   // 1) A의 자료형 = int **      ∵ A →(붕괴 O)→ &A[0]    i.e. A 자체 = 포인터 변수 (자료형: int *)   ∴ *A의 자료형:  int **  이중 포인터 변수 자료형
                                   // 2) int * []    →(붕괴 O)→   int **     ∴  int * []   ≒   int **  
                                   //    하지만 두 형식 모두 배열 전체 주소값 초기화를 위한 형식으로 선언 
                                   //    여기서 84번째줄 인수가 X 이지만, 매개변수 &A에 인수 &X를 초기화 한것으로 처리
                                   //    ∴  A = &X
                                   //       Ref) char X = 10;
                                   //            printf("%d\n", sizeof(A));   X의 크기는 초기화값 int 10의 크기 X   메모리박스 char A 크기 O
                                   //            printf("%d %c\n", X);        int 00000000 0000000 0000000 00001010 (4 Bytes) →(형변환 O)→ char 00001010 (1 Byte)
                                   // Approach 2:   정석 O
                                   // A의 자료형:  int *[] (int 포인터 배열) →(붕괴 O: [] → *)→ int ** (int 이중 포인터):  int *A[5] →(붕괴 O)→ int **A
                                   //              →  int *[] = 배열 변수 자료형 →(붕괴 O: [] → *)→ int ** = 포인터 변수 자료형:  배열 변수 자료형 →(붕괴 O)→ 포인터 변수 자료형 
                                   //              ∴  포인터 변수 자료형
                                   // A의 초기화:  선언한 자료형에 영향 받음
                                   //             Ref) char X = 10;
                                   //                  printf("%d\n", sizeof(X));   X의 크기는 초기화값 int 10의 크기 X   메모리박스 char A 크기 O
                                   //                  printf("%d %c\n", X);        int 00000000 0000000 0000000 00001010 (4 Bytes) →(형변환 O)→ char 00001010 (1 Byte)
                                   //              ∴ int *:  int [] (int 배열)  →(붕괴 O)→  int *   =  배열  →(붕괴 O)→ 배열 0번째 주소값(= 포인터 변수 형식) 초기화를 위한 자료형 (General Use)
                                   //                의 한차원 ↑ (선언시 *++)
                                   //                int **: 배열 전체 주소값(&X)을 초기화 위한 자료형 →(자료형: 포인터 변수형)→ 주소값 상수(&X[0])만 저장
                                   //                        Ref)  &X[0] 자료형:  주소값 상수
                                   //                              &X    자료형:  주소값 상수 + 배열 범위
                                   //                        i.e.  int ** = &X[0] 초기화 
                                   //              ∴ A = &X[0]                                                              
                                   //              ⇒  인수 &X[0] →(초기화)→ 매개변수 A = &X[0]    
                                   // 선언 자료형 = 초기화 자료형
                                   // ∵ (int ** 포인터 변수형: 주소값 상수 초기화) = (&X[0] 포인터 변수형: 주소값 상수)  ∴ 초기화시 선언 자료형에 맞춰 형변환 필요 X
{   
                                   // Approach 1:   정석 X
    printf("%d\n", sizeof(A));     //   A의 크기 =   (&X)의 크기 = 8 Bytes       
    printf("%d\n", sizeof(*A));    //  *A의 크기 =  *(&X)의 크기 = X의 크기 →(붕괴 O)→ &X[0]의 크기 = 8 Bytes   ∵  배열 변수에서만  sizeof 함수에서 배열 변수가 포인터 변수로 붕괴 O되지 않는 예외 Case 적용됨 
    printf("%d\n", sizeof(**A));   // **A의 크기 = **(&X)의 크기 = *X의 크기 = *(&X[0])의 크기 = 배열 요소 1의 자료형의 크기 = 4 Bytes
                                   // Approach 2:   정석 O
                                   //   sizeof(A) =   A의 자료형의 크기 = int **의 크기 = (배열 전체) 이중 포인터 변수의 크기 = 8 Bytes
                                   //  sizeof(*A) =  *A의 자료형의 크기 =  int *의 크기 = (배열) 포인터 변수 크기 = 8 Bytes 
                                   // sizeof(**A) = **A의 자료형의 크기 =    int의 크기 = 4 Bytes

    printf("%d\n", A);             // Approach 1:   정석 X
                                   // A = &X
                                   // 이중 포인터 변수에서 주소값 = (배열 전체) 주소값 상수
                                   // Approach 2:   정석 O
                                   // A = &X[0]

    printf("%d\n", *A);            // Approach 1:   정석 X 
                                   // *A = *(&X 값) = *(X 값) = *(&X[0] 값) = 1
                                   // ∵ 주소값 상수가 동일하면 가르키는 값도 동일      
                                   // ※ 이중 포인터 변수에서 주소값이 가르키는 값 = 배열 전체 주소값이 가르키는 값 = (배열 변수 = 배열 0번째 주소값)이 가르키는 값
                                   // ※ 초기화된 값(주소값 or 상수)가 동일  ➝  가르키는/참조하는  값/변수도 동일  
                                   // Image  참조
                                   // Approach 2:   정석 O
                                   // *A = *(&X[0]) = 1 

    printf("%d\n", *(A + 1));      // Approach 1:   정석 X 
                                   // *(A + 1) = *(&X + 1) = *(&X + &X의 자료형이 가르키는 값의 크기) = *(&X + 배열 X 크기) →(붕괴 O)→ *(&X + &X[0]의 크기) = *(&X[0] + 8 Bytes) = *(&X[2])
                                   // 1 = A의 자료형이 가르키는 값의 크기  
                                   //   = int ** 이 가르키는 값의 크기 
                                   //   = int * 크기 
                                   //   = 배열 X의 크기 →(붕괴 O)→ &X[0]의 크기
                                   //   = 주소값 크기
                                   //   = 8 Bytes
                                   // ∴ *(A + 1)  →  *(&X[0] + 8) = *(&X[2]) = 3
                                   // ⇒  A = &X[0] 이며, A = &X가 실제로 아님을 알 수 있음  ➝  15번째줄 Approach 2: 정석 O 참고
                                   // Approach 2:   정석 O
                                   // *(A + 1) = *(A + A의 자료형이 가르키는 값의 크기) = *(A + int **가 가르키는 값의 크기) = *(A + int *) = *(&X[0] + 8 Bytes) = *(&X[2]) = 3  

    printf("%d\n", *A + 1);        // Approach 1:   정석 X 
                                   // *A + 1 = [29번째 줄 참조: *(&X 값) + 1 = *(X 값) + 1 = *(&X[0] 값) + 1] = *(&X[0]) + *(&X[0])의 자료형이 가르키는 값의 크기 = *(&X[0]) + 배열 요소 1의 크기 = &X[0] + 4 Bytes 
                                   // 1 = *A의 자료형이 가르키는 값의 크기
                                   //   = int ** 자료형이 가르키는 값의 자료형이 가르키는 값의 크기
                                   //   = int * 이 가르키는 값의 크기
                                   //   = 배열 X가 가르키는 값의 크기 →(붕괴 O)→ &X[0]이 가르키는 값의 크기 
                                   //   = 배열 요소 1의 크기
                                   //   = int 4 Bytes
                                   // ∴ *A + 1  →  *(&X[0]) + 4 = 1 + 4 = 5
                                   // ⇒ A = &X[0] 이며, A = &X가 실제로 아님을 알 수 있음  ➝  15번째줄 Approach 2: 정석 O 참고
                                   // Approach 2:   정석 O
                                   // *A + 1 = *A + *A의 자료형이 가르키는 값의 크기 = *A + int **가 가르키는 값의 자료형이 가르키는 값의 크기 = = *A + int *가 가르키는 값의 크기 = *(&X[0]) + 4 Bytes = 1 + 4 = 5   
}

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int *X_ptr = X;                // 1)   선언   자료형: int *   포인터 변수 자료형: : 주소값 상수 초기화
                                   // 2)   초기화 자료형: X →(붕괴 O)→ &X[0]  포인터 변수 자료형: : 주소값 상수
                                   // ⇒   선언 자료형 = 초기화 자료형  i.e. &X[0]의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X[0]
                                   // Ref) If  X →(붕괴 X):  X의 자료형은 배열이므로 int * 자료형에 초기화 되려면 주소값 형식 &X[0]으로 형변환 되어 초기화됨
    printf("%d\n", X_ptr);         // &X[0]
    printf("%d\n", *X_ptr);        // *(&X[0]) = 1 

    printf("%d\n", sizeof(X));     // sizeof: 배열 X →(붕괴 X)     ∴ 배열 X의 크기 = 20

    function_1(X);                 // X →(붕괴 O)→ &X[0]  ⇒  function_1(&X[0]);           
    function_2(X);                 // X →(붕괴 O)→ &X[0]  ⇒  function_1(&X[0]);        
 
    return 0;
}
// Conclusion:  초기화 자료형에 관계없이 선언 자료형에 초기화 변수 형식(값) Fitting     ∴ 초기화 자료형은 사실 無 


```

![](https://t9003081320.p.clickup-attachments.com/t9003081320/c8f092fe-24c0-412a-a495-9e8bc03b3cf5/Picture5.png)

**c\_pointer\_array\_6b\_ref\_3.c**
※ int \* \[\] (int 포인터 배열) →(붕괴 O)→ int \*\* (int 이중 포인터)

```plain
// 사용자 정의 함수에서 배열 변수 →(붕괴 O)→ 포인터 변수 
#include <stdio.h>

void function_1(int A[5])           // A의 자료형:  int [] (int 배열) →(붕괴 O)→ int * (int 포인터):  int A[5] →(붕괴 O)→ int *
                                    //             →  int [] = 배열 변수 자료형  →(붕괴 O)→  int * 포인터 변수 자료형  
                                    // A의 초기화:  선언한 자료형에 영향 받음
                                    //             Ref) char X = 10;
                                    //                  printf("%d\n", sizeof(X));   X의 크기는 초기화값 int 10의 크기 X   메모리박스 char A 크기 O
                                    //                  printf("%d %c\n", X);        int 00000000 0000000 0000000 00001010 (4 Bytes) →(형변환 O)→ char 00001010 (1 Byte)
                                    //             ∴ int *: 배열 →(붕괴 O)→ 포인터 변수
                                    //                      i.e.  int * = &X[0] 초기화
                                    //             ∴ A = &X →(형변환)→ &X[0]       ※  X →(붕괴 O)→ &X[0] 아님
                                    //                    - &X:      주소값 상수 + 배열 범위   
                                    //                    - &X[0]:   주소값 상수          
                                    //             i.e  인수 &X  →(초기화)→  매개변수 A = &X[0]     ※  인수 &X →(형변환 O)→ 매개변수 &X[0] 개념
                                    // 선언 자료형 ≠ 초기화 자료형 
                                    // ∵  (int * 포인터 변수형: 주소값 상수 초기화) ≠ (&X 포인터 변수형:  주소값 상수 + 배열 범위)   ∴ 초기화시 선언 자료형에 맞춰 형변환 필요 O
{

    printf("%d\n", sizeof(A));      //  sizeof(A) =  A의 자료형의 크기 = int *의 크기 = 8 Bytes
    printf("%d\n", sizeof(*A));     // sizeof(*A) = *A의 자료형의 크기 =  int 의 크기 = 4 Bytes

    printf("%d\n", A);              // A = &X[0]
    printf("%d\n", *A);             // A = *(&X[0]) = 1

    printf("%d\n", *(A + 1));       // *(A + 1) = *(A + A의 자료형이 가르키는 값의 크기) = *(A + int *가 가르키는 값의 크기) = *(A + 4 Bytes) = *(&X[0] + 4 Bytes) = *(&X[1]) = 2
    printf("%d\n", *A + 1);         // *A + *A의 자료형이 가르키는 값의 크기 = *A + int *가 가르키는 값의 자료형이 가르키는 값의 크기 = *A + int가 가르키는 값의 크기 = *(&X[0]) + 1 = 1 + 1 = 2 
}
// 언제 배열 변수가 포인터 변수로 붕괴 O되는지? 언제 sizeof() 함수를 사용하는지? 주목

// int * [] (int 포인터 배열) →(붕괴 O)→ int ** (int 이중 포인터)
void function_2(int *A[5])           // A의 자료형:  int *[] (int 포인터 배열) →(붕괴 O: [] → *)→ int ** (int 이중 포인터):  int *A[5] →(붕괴 O)→ int **A
                                   //              →  int *[] = 배열 변수 자료형 →(붕괴 O: [] → *)→ int ** = 포인터 변수 자료형:  배열 변수 자료형 →(붕괴 O)→ 포인터 변수 자료형 
                                   //              ∴  포인터 변수 자료형
                                     // A의 초기화:  선언한 자료형에 영향 받음
                                     //             Ref) char X = 10;
                                     //                  printf("%d\n", sizeof(X));   X의 크기는 초기화값 int 10의 크기 X   메모리박스 char A 크기 O
                                     //                  printf("%d %c\n", X);        int 00000000 0000000 0000000 00001010 (4 Bytes) →(형변환 O)→ char 00001010 (1 Byte)
                                     //              ∴ int *:  int [] (int 배열)  →(붕괴 O)→  int *   =  배열  →(붕괴 O)→ 배열 0번째 주소값(= 포인터 변수 형식) 초기화를 위한 자료형 (General Use)
                                     //                의 한차원 ↑ (선언시 *++)
                                     //                int **: 배열 전체 주소값(&X)을 초기화 위한 자료형 →(자료형: 포인터 변수형)→ 주소값 상수(&X[0])만 저장
                                     //                        Ref)  &X[0] 자료형:  주소값 상수
                                     //                              &X    자료형:  주소값 상수 + 배열 범위
                                     //                        i.e.  int ** = &X[0] 초기화
                                     //              ∴ A = &X →(형변환)→ 개념 &(&X[0]) ⇒ 실제 &X[0] 
                                     //                    인      수:   &X      자료형 = 주소값 상수 + 범위
                                     //                    초기화 개념: &(&X[0]) 자료형 = 주소값의 주소값 (실존 X)
                                     //                    초기화 실졔:   &[0]   자료형 = 주소값 상수     (실존 O)
                                     //                A = &X[0]
                                     //              i.e   인수 &X →(초기화)→ 매개변수 A = &X[0]
                                     // 선언 자료형 ≠ 초기화 자료형
                                     // ∵ (int ** 포인터 변수형: 주소값 상수 초기화) ≠ (&X 포인터 변수형: 주소값 상수 + 배열 범위 초기화)  ∴ 초기화시 선언 자료형에 맞춰 형변환 필요 O            
{
    printf("%d\n", sizeof(A));       //  sizeof(A) =   A의 자료형의 크기 = int **의 크기 = (배열 전체) 이중 포인터 변수의 크기 = 8 Bytes
    printf("%d\n", sizeof(*A));      // sizeof(*A) =  *A의 자료형의 크기 =  int *의 크기 = (배열) 포인터 변수 크기 = 8 Bytes 

    printf("%d\n", A);               //  A =   &X[0]
    printf("%d\n", *A);              // *A = *(&X[0]) = 1 

    printf("%d\n", *(A + 1));        // *(A + 1) = *(A + A의 자료형이 가르키는 값의 크기) = *(A + int **가 가르키는 값의 크기) = *(A + int *) = *(&X[0] + 8 Bytes) = *(&X[2]) = 3  
    printf("%d\n", *A + 1);          // *A + 1 = *A + *A의 자료형이 가르키는 값의 크기 = *A + int **가 가르키는 값의 자료형이 가르키는 값의 크기 = = *A + int *가 가르키는 값의 크기 = *(&X[0]) + 4 Bytes = 1 + 4 = 5   
}
// 언제 배열 변수가 포인터 변수로 붕괴 O되는지? 언제 sizeof() 함수를 사용하는지? 주목

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int(*X_ptr)[5] = &X;             // 1)   선언   자료형: int (*)[]  포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화
                                     // 2)   초기화 자료형: &X         포인터 변수 자료형: 주소값 상수 + 배열 범위
                                     // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X
    printf("%d\n", X_ptr);           // &X
    printf("%d\n", *X_ptr);          // *(&X) = X →(붕괴 O)→ &X[0] 
    printf("%d\n", **X_ptr);         // *(&X[0]) = 1

    printf("%d\n", sizeof(X));       // sizeof: 배열 X →(붕괴 X)     ∴ 배열 X의 크기 = 20

    function_1(&X);                  // &X: 배열 변수 →(붕괴 X)→ 포인터 변수  ∴ 인수 = &X 
    function_2(&X);                  // &X: 배열 변수 →(붕괴 X)→ 포인터 변수  ∴ 인수 = &X 

    return 0;
}
// Conclusion:  초기화 자료형에 관계없이 선언 자료형에 초기화 변수 형식(값) Fitting     ∴ 초기화 자료형은 사실 無 


```

**c\_pointer\_array\_6b\_ref\_4.c**
※ int (\*)\[\]  (int 포인터 배열 전체) →(붕괴 X)

```plain
// 사용자 정의 함수에서 배열 변수 →(붕괴 O)→ 포인터 변수 
#include <stdio.h>

void function_1(int A[5])          // A의 자료형:  int [] (int 배열) →(붕괴 O)→ int * (int 포인터):  int A[5] →(붕괴 O)→ int *
                                   //             →  int [] = 배열 변수 자료형  →(붕괴 O)→ int * = 포인터 변수 자료형 
                                   // A의 초기화:  선언한 자료형에 영향 받음
                                   //             Ref) char X = 10;
                                   //                  printf("%d\n", sizeof(X));   X의 크기는 초기화값 int 10의 크기 X   메모리박스 char A 크기 O
                                   //                  printf("%d %c\n", X);        int 00000000 0000000 0000000 00001010 (4 Bytes) →(형변환 O)→ char 00001010 (1 Byte)
                                   //             ∴ int *: 배열 →(붕괴 O)→ 포인터 변수
                                   //                      i.e.  int * = &X[0] 초기화
                                   //             ∴ A = &X[0]                   
                                   //             ⇒    인수 &X[0]  →(초기화)→  매개변수 A = &X[0]      
                                   // 선언 자료형 = 초기화 자료형 
                                   // ∵  (int * 포인터 변수형: 주소값 상수 초기화) = (&X[0] 포인터 변수형: 주소값 상수)   ∴ 초기화시 선언 자료형에 맞춰 형변환 필요 X   
{

    printf("%d\n", sizeof(A));     //  sizeof(A) =  A의 자료형의 크기 = int *의 크기 = 8 Bytes
    printf("%d\n", sizeof(*A));    // sizeof(*A) = *A의 자료형의 크기 =  int 의 크기 = 4 Bytes

    printf("%d\n", A);             // A = &X[0]
    printf("%d\n", *A);            // A = *(&X[0]) = 1

    printf("%d\n", *(A + 1));      // *(A + 1) = *(A + A의 자료형이 가르키는 값의 크기) = *(A + int *가 가르키는 값의 크기) = *(A + 4 Bytes) = *(&X[0] + 4 Bytes) = *(&X[1]) = 2
    printf("%d\n", *A + 1);        // *A + *A의 자료형이 가르키는 값의 크기 = *A + int *가 가르키는 값의 자료형이 가르키는 값의 크기 = *A + int가 가르키는 값의 크기 = *(&X[0]) + 1 = 1 + 1 = 2 
}

//  int (*)[]  (int 포인터 배열 전체) →(붕괴 X) 
void function_2(int (*A)[5])       // A의 자료형: int (*)[] (int 포인터 배열 전체)  
                                   //             →  int (*)[] = 포인터 변수 자료형 →(붕괴 X)
                                   //             ∴  포인터 변수 자료형
                                   // A의 초기화: 선언한 자료형에 영향 받음
                                   //             Ref) char X = 10;
                                   //                  printf("%d\n", sizeof(X));   X의 크기는 초기화값 int 10의 크기 X   메모리박스 char A 크기 O
                                   //                  printf("%d %c\n", X);        int 00000000 0000000 0000000 00001010 (4 Bytes) →(형변환 O)→ char 00001010 (1 Byte)
                                   //             ∴ int (*)[]: 배열 전체 주소값(&X)을 초기화 위한 자료형 →(자료형: 포인터 변수형 + "[]")→ 주소값 상수 + "배열 범위(&X)" = &X
                                   //                          Ref)  &X[0] 자료형:  주소값 상수
                                   //                                &X    자료형:  주소값 상수 + 배열 범위
                                   //                          i.e.  int (*[]) = &X 초기화
                                   //             ∴ A = &X[0] →(형변환 O)→ &X  
                                   //             i.e   인수 &X[0] →(초기화)→ 매개변수 A = &X  
                                   // 선언 자료형 ≠ 초기화 자료형 
                                   // ∵ (int (*)[] 포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화) ≠ (&X[0] 포인터 변수형: 주소값 상수)  ∴ 초기화시 선언 자료형에 맞춰 형변환 필요 O
{
    printf("%d\n", sizeof(A));     //  sizeof(A) =  A의 자료형의 크기 = int (*)[]의 크기 = 배열 A 전체 주소값의 크기
    printf("%d\n", sizeof(*A));    // sizeof(*A) = *A의 자료형의 크기 = int []의 크기 →(sizeof 함수: 붕괴 X) = 배열 A의 크기 = 배열 요소 크기 x 배열 요소 갯수 = 4 Bytes x 5개 = 20 Bytes 

    printf("%d\n", A);             //  A =   &X
    printf("%d\n", *A);            // *A = *(&X) = X →(붕괴 O)→ &X[0] 

    printf("%d\n", *(A + 1));      // *(A + 1) = *(A + A의 자료형이 가르키는 값의 크기) = *(A + int (*)[]가 가르키는 값의 크기) = *(A + int []) = *(&X + 20 Bytes) = *(&X의 오른쪽 옆 전체 배열의 주소값)
                                   //                                                                                                 int [] →(붕괴 X)→ int *     ∵ A = int (*)[]: 포인터 변수 자료형으로 붕괴 X
    printf("%d\n", *A + 1);        // *A + 1 = *A + *A의 자료형이 가르키는 값의 크기 = *A + int (*)[]가 가르키는 값의 자료형이 가르키는 값의 크기 = *A + int []가 가르키는 값의 크기 = *(&X) + int []가 가르키는 값의 크기 = X + int []가 가르키는 값의 크기 = (X →(붕괴 O)→ &X[0]) + (int [] →(붕괴 O)→ int *가 가르키는 값의 크기) 4 = &X[0] + 4 Bytes = &X[1]
                                   //
                                   // 언제 배열 변수가 포인터 변수로 붕괴 되는지? 언제 sizeof() 함수를 사용하는지? 주목                                                                                                                                                                                                                                       int [] →(붕괴 O)→ int *   ∵ *A =  int []: 배열 변수 자료형으로 붕괴 O                                        
}

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int *X_ptr = X;                // 1)   선언   자료형: int *   포인터 변수 자료형: 주소값 상수 초기화
                                   // 2)   초기화 자료형: X →(붕괴 O)→ &X[0]  포인터 변수 자료형: : 주소값 상수
                                   // ⇒   선언 자료형 = 초기화 자료형  i.e. &X[0]의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X[0]
                                   // Ref) If  X →(붕괴 X)→ &X[0]:    X의 자료형은 배열이므로 int * 자료형에 초기화 되려면 주소값 형식 &X[0]으로 형변환 되어 초기화됨
    printf("%d\n", X_ptr);         // &X[0]
    printf("%d\n", *X_ptr);        // *(&X[0]) = 1 

    printf("%d\n", sizeof(X));     // sizeof: 배열 X →(붕괴 X)   ∴ 배열 X의 크기 = 20

    function_1(X);                 // X →(붕괴 O)→ &X[0]  ⇒  function_1(&X[0]);          
    function_2(X);                 // X →(붕괴 O)→ &X[0]  ⇒  function_1(&X[0]);     

    return 0;
}
// Conclusion:  초기화 자료형에 관계없이 선언 자료형에 초기화 변수 형식(값) Fitting     ∴ 초기화 자료형은 사실 無 


```

**c\_pointer\_array\_6b\_ref\_5.c**

```plain
// 사용자 정의 함수에서 배열 변수 →(붕괴 O)→ 포인터 변수 
#include <stdio.h>

void function_1(int A[5])          // A의 자료형:  int [] (int 배열) →(붕괴 O)→ int * (int 포인터):  int A[5] →(붕괴 O)→ int *
                                   //             →  int [] = 배열 변수 자료형  →(붕괴 O)→  int * 포인터 변수 자료형
                                   //             ∴  포인터 변수 자료형
                                   // A의 초기화:  선언한 자료형에 영향 받음
                                   //             Ref) char X = 10;
                                   //                  printf("%d\n", sizeof(X));   X의 크기는 초기화값 int 10의 크기 X   메모리박스 char A 크기 O
                                   //                  printf("%d %c\n", X);        int 00000000 0000000 0000000 00001010 (4 Bytes) →(형변환 O)→ char 00001010 (1 Byte)
                                   //             ∴ int *: 배열 →(붕괴 O)→ 포인터 변수
                                   //                      i.e.  int * = &X[0] 초기화
                                   //             ∴ A = &X →(형변환)→ &X[0]       ※  X →(붕괴 O)→ &X[0] 아님
                                   //                    - &X:      주소값 상수 + 배열 범위   
                                   //                    - &X[0]:   주소값 상수    
                                   //             i.e  인수 &X  →(초기화)→  매개변수 A = &X[0]     ※  인수 &X →(형변환 O)→ 매개변수 &X[0] 개념
                                   // 선언 자료형 ≠ 초기화 자료형 
                                   // ∵  (int * 포인터 변수형: 주소값 상수 초기화) ≠ (&X 포인터 변수형: 주소값 상수 + 배열 범위)  ∴ 초기화시 선언 자료형에 맞춰 형변환 필요 O 
{
    printf("%d\n", sizeof(A));     //  sizeof(A) =  A의 자료형의 크기 = int *의 크기 = 8 Bytes
    printf("%d\n", sizeof(*A));    // sizeof(*A) = *A의 자료형의 크기 = int 의 크기 = 4 Bytes 

    printf("%d\n", A);             // A = &X[0]
    printf("%d\n", *A);            // A = *(&X[0]) = 1

    printf("%d\n", *(A + 1));      // *(A + 1) = *(A + A의 자료형이 가르키는 값의 크기) = *(A + int *가 가르키는 값의 크기) = *(A + 4 Bytes) = *(&X[0] + 4 Bytes) = *(&X[1]) = 2
    printf("%d\n", *A + 1);        // *A + *A의 자료형이 가르키는 값의 크기 = *A + int *가 가르키는 값의 자료형이 가르키는 값의 크기 = *A + int가 가르키는 값의 크기 = *(&X[0]) + 1 = 1 + 1 = 2
}

//  int (*)[]  (int 포인터 배열 전체) →(붕괴 X)
void function_2(int (*A)[5])       // A의 자료형: int (*)[] (int 포인터 배열 전체)  
                                   //             →  int (*)[] = 포인터 변수 자료형 →(붕괴 X)
                                   //             ∴  포인터 변수 자료형
                                   // A의 초기화: 선언한 자료형에 영향 받음
                                   //             Ref) char X = 10;
                                   //                  printf("%d\n", sizeof(X));   X의 크기는 초기화값 int 10의 크기 X   메모리박스 char A 크기 O
                                   //                  printf("%d %c\n", X);        int 00000000 0000000 0000000 00001010 (4 Bytes) →(형변환 O)→ char 00001010 (1 Byte)
                                   //             ∴ int (*)[]: 배열 전체 주소값(&X)을 초기화 위한 자료형 →(자료형: 포인터 변수형 + "[]")→ 주소값 상수 + "배열 범위(&X)" = &X
                                   //                          Ref)  &X[0] 자료형:  주소값 상수
                                   //                                &X    자료형:  주소값 상수 + 배열 범위
                                   //                          i.e.  int (*[]) = &X 초기화
                                   //             ∴ A = &X 
                                   //             i.e   인수 &X →(초기화)→ 매개변수 A = &X 
                                   // 선언 자료형 = 초기화 자료형
                                   // ∵ (int (*)[] 포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화) = (&X 포인터 변수 자료형: 주소값 상수 + 배열 범위)  ∴ 초기화시 선언 자료형에 맞춰 형변환 필요 X
{
    printf("%d\n", sizeof(A));     //  sizeof(A) =  A의 자료형의 크기 = int (*)[]의 크기 = 배열 A 전체 주소값의 크기
    printf("%d\n", sizeof(*A));    // sizeof(*A) = *A의 자료형의 크기 = int []의 크기 →(sizeof 함수: 붕괴 X) = 배열 A의 크기 = 배열 요소 크기 x 배열 요소 갯수 = 4 Bytes x 5개 = 20 Bytes 

    printf("%d\n", A);             //  A =   &X
    printf("%d\n", *A);            // *A = *(&X) = X →(붕괴 O)→ &X[0] 

    printf("%d\n", *(A + 1));      // *(A + 1) = *(A + A의 자료형이 가르키는 값의 크기) = *(A + int (*)[]가 가르키는 값의 크기) = *(A + int []) = *(&X + 20 Bytes) = *(&X의 오른쪽 옆 전체 배열의 주소값)
                                   //                                                                                            sizeof(int []) →(붕괴 X)→ sizeof(int *)     ∵ A = int (*)[]: 포인터 변수 자료형으로 붕괴 X
    printf("%d\n", *A + 1);        // *A + 1 = *A + *A의 자료형이 가르키는 값의 크기 = *A + int (*)[]가 가르키는 값의 자료형이 가르키는 값의 크기 = *A + int []가 가르키는 값의 크기 = *(&X) + int []가 가르키는 값의 크기 = X + int []가 가르키는 값의 크기 = (X →(붕괴 O)→ &X[0]) + (int [] →(붕괴 O)→ int *가 가르키는 값의 크기) 4 = &X[0] + 4 Bytes = &X[1]
                                   //
                                   // 언제 배열 변수가 포인터 변수로 붕괴 되는지? 언제 sizeof() 함수를 사용하는지? 주목                                                                                                                                                               int [] →(붕괴 O)→ int * 가 가르키는 값의 크기  ∵ sizeof(*A) =  int [] →(붕괴 O)→ int * 후 sizeof 함수 사용                                         
}


int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int(*X_ptr)[5] = &X;           // 1)   선언   자료형: int (*)[]  포인터 변수 자료형: 주소값 상수 + 배열 범위 초기화
                                   // 2)   초기화 자료형: &X         포인터 변수 자료형: 주소값 상수 + 배열 범위
                                   // ⇒   선언 자료형 = 초기화 자료형  i.e. &X의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X
    printf("%d\n", X_ptr);         // &X
    printf("%d\n", *X_ptr);        // *(&X) = X →(붕괴 O)→ &X[0] 
    printf("%d\n", **X_ptr);       // *(&X[0]) = 1
    
    printf("%d\n", sizeof(X));     // sizeof: 배열 X →(붕괴 X)     ∴ 배열 X의 크기 = 20

    function_1(&X);                // &X: 배열 변수 →(붕괴 X)→ 포인터 변수  ∴ 인수 = &X 
    function_2(&X);                // &X: 배열 변수 →(붕괴 X)→ 포인터 변수  ∴ 인수 = &X 

    return 0;
}
// Conclusion:  초기화 자료형에 관계없이 선언 자료형에 초기화 변수 형식(값) Fitting     ∴ 초기화 자료형은 사실 無 


```

**c\_pointer\_array\_6b.c**

```plain
#include <stdio.h>
// 사용자 정의 함수에서 배열 변수 →(붕괴)→ 포인터 변수 
void function_1(int A[5])           // A의 자료형:  int [] (int 배열) →(붕괴 O)→ int * (int 포인터):  int A[5] →(붕괴 O)→ int *
                                    //             →  int [] = 배열 변수 자료형  →(붕괴 O)→ int * = 포인터 변수 자료형
                                    // A의 초기화:  인수 X 배열 변수 자료형  →   매개변수 A(포인터 변수 자료형): X →(형변환)→ &X[0] 초기화
                                    //             i.e. X  →(붕괴 X)→ &X[0] 개념이 아님, 형변환으로 &X[0]이 초기화           
{
    printf("%d\n", sizeof(A));      // A의 크기 =   A의 자료형의 크기 = int *의 크기 = 8 Bytes 
    printf("%d\n", sizeof(*A));     // *A의 크기 = *A의 자료형의 크기 =  int 의 크기 = 4 Bytes 

    printf("%d\n", A);              // A = &X[0]
    printf("%d\n", *A);             // *A = *(&X[0]) = 1
    printf("%d\n", *(A + 1));       // *(A + 1) = *(A + A의 자료형이 가르키는 값의 크기) = *(A + int *가 가르키는 값의 크기) = *(A + 4 Bytes) = *(&X[0] + 4 Bytes) = *(&X[1]) = 2
    printf("%d\n", *A + 1);         // *A + 1 = *A + *A의 자료형이 가르키는 값의 크기 = *A + int가 가르키는 값의 크기) = *A + 1 = *(&X[0]) + 1 = 1 + 1 = 2
}
 
void function_2(int *A_ptr)         // A_ptr의 자료형:  int * (int 포인터)
                                    // A_ptr의 초기화:  인수 X 배열 변수 자료형  →   매개변수 A(포인터 변수 자료형): X →(형변환)→ &X[0] 초기화
                                    //                 i.e. X  →(붕괴 X)→ &X[0] 개념이 아님, 형변환으로 &X[0]이 초기화                
{
    printf("%d\n", A_ptr);         // A_ptr = &X[0]
    printf("%d\n", *A_ptr);        // *A_ptr = *(&X[0]) = 1
    printf("%d\n", *(A_ptr + 1));  // *(A_ptr + 1) = *(A_ptr + A의 자료형이 가르키는 값의 크기) = *(A_ptr + int *가 가르키는 값의 크기) = *(A_ptr + 4 Bytes) = *(&X[0] + 4 Bytes) = *(&X[1]) = 2
    printf("%d\n", *A_ptr + 1);    // *A_ptr + 1 = *A_ptr + *A의 자료형이 가르키는 값의 크기 = *A_ptr + int가 가르키는 값의 크기) = *A_ptr + 1 = *(&X[0]) + 1 = 1 + 1 = 2   
}

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int *X_ptr = X;                // 1)   선언   자료형: int *   포인터 변수 자료형: : 주소값 상수 초기화
                                   // 2)   초기화 자료형: X →(붕괴 O)→ &X[0]  포인터 변수 자료형: : 주소값 상수
                                   // ⇒   선언 자료형 = 초기화 자료형  i.e. &X[0]의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X[0]
                                   // Ref) If  X →(붕괴 X):  X의 자료형은 배열이므로 int * 자료형에 초기화 되려면 주소값 형식 &X[0]으로 형변환 되어 초기화됨                

    function_1(X);
    function_2(X_ptr);            
 
    return 0;
}


```

**c\_pointer\_array\_6c.c**

```plain
#include <stdio.h>

void function_1(int array[5])                       // array의 자료형:  int [] (int 배열) →(붕괴 O)→ int * (int 포인터):  int array[5] →(붕괴 O)→ int *
                                                    //                 →  int [] = 배열 변수 자료형  →(붕괴 O)→ int * = 포인터 변수 자료형
                                                    // array의 초기화:  인수 X 배열 변수 자료형  →   매개변수 array(포인터 변수 자료형): X →(형변환)→ &X[0] 초기화
                                                    //                 i.e. X  →(붕괴 X)→ &X[0] 개념이 아님, 형변환으로 &X[0]이 초기화     
{
    printf("function_1\n");
    printf("array[5]의 size %d\n", sizeof(array));  // 3번째 줄에서 이미 붕괴된 다음 sizeof 처리하므로 sizeof에 의한 예외 Case(배열 [] →(붕괴 X)→ 포인터 *) 적용 X
                                                    // sizeof(array) = int * 크기 = 8 Bytes
                                                    // If ⇒ sizeof에 의한 예외 Case O: array[5] = array →(붕괴 X)  →  sizeof(array) = 4 Bytes(배열 요소 크기) * 5개(배열 요소 갯수) = 20   
}

void function_2(int *ptr)                           // ptr의 자료형:  int * (int 포인터)
                                                    //               →  포인터 변수 자료형
                                                    // ptr의 초기화:  인수 X 배열 변수 자료형  →   매개변수 ptr(포인터 변수 자료형): X →(형변환)→ &X[0] 초기화
                                                    //               i.e. X  →(붕괴 X)→ &X[0] 개념이 아님, 형변환으로 &X[0]이 초기화    
{
    printf("function_2\n");
    printf("ptr의 size %d\n", sizeof(ptr));         // sizeof(ptr) = int * 크기 = 8 Bytes    
}

int main()
{
    int X[5] = {1, 2, 3, 4, 5};
    int *X_ptr = X;                                 // 1)   선언   자료형: int *   포인터 변수 자료형: : 주소값 상수 초기화
                                                    // 2)   초기화 자료형: X →(붕괴 O)→ &X[0]  포인터 변수 자료형: : 주소값 상수
                                                    // ⇒   선언 자료형 = 초기화 자료형  i.e. &X[0]의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X[0]
                                                    // Ref) If  X →(붕괴 X):  X의 자료형은 배열이므로 int * 자료형에 초기화 되려면 주소값 형식 &X[0]으로 형변환 되어 초기화됨  

    X_ptr = X;                                      // X →(붕괴)→ &X[0] 

    function_1(X);                                  // X →(붕괴 O)→ &X[0]  ⇒  function_1(&X[0]);    
    printf("================\n");
    function_2(X);                                  // X →(붕괴 O)→ &X[0]  ⇒  function_1(&X[0]);    
    printf("================\n");

    function_1(&X[0]);           
    printf("================\n");
    function_2(&X[0]);
    printf("================\n");

    function_1(X_ptr);                              // X_ptr = X →(붕괴 O)→ &X[0]  ⇒  function_1(&X[0]);          
    printf("================\n");
    function_2(X_ptr);                              // X_ptr = X →(붕괴 O)→ &X[0]  ⇒  function_1(&X[0]);      
    printf("================\n");

    return 0;
}


```

**c\_pointer\_array\_6d.c**

```plain
#include <stdio.h>

// 매개변수 배열 [], 함수내 배열 []
void function_1(int array[], int length)            // array의 자료형:  int [] (int 배열) →(붕괴 O)→ int * (int 포인터):  int array[5] →(붕괴 O)→ int *
                                                    //                 →  int [] = 배열 변수 자료형  →(붕괴 O)→ int * = 포인터 변수 자료형
                                                    // array의 초기화:  인수 X 배열 변수 자료형  →   매개변수 array(포인터 변수 자료형): X →(형변환)→ &X[0] 초기화
                                                    //                 i.e. X  →(붕괴 X)→ &X[0] 개념이 아님, 형변환으로 &X[0]이 초기화   
{
    printf(" function_1\n");    
    for (int i = 0; i < length; i++)
    {
        printf("array[%d]: %d\n", i, array[i]);     // array[i] = (&X[0])[i] 
    }
}

// 매개변수 포인터 *, 함수내 포인터 *
void function_2(int *ptr, int length)               // ptr의 자료형:  int * (int 포인터)
                                                    //               →  포인터 변수 자료형
                                                    // ptr의 초기화:  인수 X 배열 변수 자료형  →   매개변수 ptr(포인터 변수 자료형): X →(형변환)→ &X[0] 초기화
                                                    //
{
    printf(" function_2\n");    
    for (int i = 0; i < length; i++)
    {
        printf("  ptr[%d]: %d\n", i, *(ptr + i));    //  i = 1:  *(ptr + ptr의 자료형이 가르키는 값의 크기) = *(ptr + int *가 가르키는 값의 크기) = *(ptr + 4 Bytes) = *(&X[0] + 4 Bytes) = *(&X[1]) = 2 
    }
}

// 매개변수 포인터 *, 함수내 배열 []
void function_3(int *ptr, int length)                // ptr의 자료형:  int * (int 포인터)
                                                     //               →  포인터 변수 자료형
                                                     // ptr의 초기화:  인수 X 배열 변수 자료형  →   매개변수 ptr(포인터 변수 자료형): X →(형변환)→ &X[0] 초기화
                                                     //
{
    printf(" function_3\n");    
    for (int i = 0; i < length; i++)
    {
        printf("array[%d]: %d\n", i, ptr[i]);        // ptr[i] = (&X[0])[i] 
    }
}

// 매개변수 배열 [], 함수내 포인터 *
void function_4(int array[], int length)             // array의 자료형:  int [] (int 배열) →(붕괴 O)→ int * (int 포인터):  int array[5] →(붕괴 O)→ int *
                                                     //                 →  int [] = 배열 변수 자료형  →(붕괴 O)→ int * = 포인터 변수 자료형
                                                     // array의 초기화:  인수 X 배열 변수 자료형  →   매개변수 array(포인터 변수 자료형): X →(형변환)→ &X[0] 초기화
                                                     // 
{
    printf(" function_4\n");    
    for (int i = 0; i < length; i++)
    {
        printf("  ptr[%d]: %d\n", i, *(array + i));  // i = 1:  *(ptr + ptr의 자료형이 가르키는 값의 크기) = *(ptr + int *가 가르키는 값의 크기) = *(ptr + 4 Bytes) = *(&X[0] + 4 Bytes) = *(&X[1]) = 2 
    }
}

int main()
{
   int X[5] = {1, 2, 3, 4, 5};
    int *X_ptr = X;                                 // 1)   선언   자료형: int *   포인터 변수 자료형: : 주소값 상수 초기화
                                                    // 2)   초기화 자료형: X →(붕괴 O)→ &X[0]  포인터 변수 자료형: : 주소값 상수
                                                    // ⇒   선언 자료형 = 초기화 자료형  i.e. &X[0]의 형변환 필요없이 X_ptr에 초기화:  X_ptr = &X[0]
                                                    // Ref) If  X →(붕괴 X):  X의 자료형은 배열이므로 int * 자료형에 초기화 되려면 주소값 형식 &X[0]으로 형변환 되어 초기화됨  

    X_ptr = X;                                      // X →(붕괴)→ &X[0] 

    function_1(X, 5);                               // X →(붕괴 O)→ &X[0]  ⇒  function_1(&X[0], 5);   
    printf("============\n");   
    function_2(X, 5);
    printf("============\n"); 
    function_3(X, 5);
    printf("============\n"); 
    function_4(X, 5);
    printf("============\n"); 

    function_1(&X[0], 5);
    printf("============\n");   
    function_2(&X[0], 5);
    printf("============\n"); 
    function_3(&X[0], 5);
    printf("============\n"); 
    function_4(&X[0], 5);
    printf("============\n"); 

    function_1(X_ptr, 5);                            // X_ptr = X →(붕괴 O)→ &X[0]  ⇒  function_1(&X[0], 5); 
    printf("============\n"); 
    function_2(X_ptr, 5);
    printf("============\n"); 
    function_3(X_ptr, 5);
    printf("============\n"); 
    function_4(X_ptr, 5);
    printf("============\n"); 

    return 0;
}


```

※ 사용자정의 함수 매개변수 →  배열 변수 or 배열 포인터 변수 사용 가능 O
Code 내용에 따라 더 직관적 변수 Type 선정
※ 매개변수 = 배열 포인터 변수 /  함수내부 배열 변수 사용 가능 O (예: function\_3)
매개변수 = 배열 변수 /  함수내부 배열 포인터 변수 사용 가능 O (예: function\_4)
# Int  Char  Float

# **int float char 정수 소수 문자**

### #1 Declaration/Initialisation/Use 선언/초기화/사용
#### #1-1 포인터 변수 선언 및 초기화
`자료형 *변수`
자료형 포인터+포인터 변수
→ 포인터 변수는 주소값(첫번째 Byte) 초기화 역할
→ 포인터 변수는 주소값의 영향력 범위 지정 역할
\= 주소값이 가르키는/참조하는 값/변수의 자료형의 종류/크기 지정 역할
∴ `자료형`: 주소값이 가르키는값/참조하는 값/변수의 자료형 + `*`
예: int \*, char \*, float \*

예:
char Y = 'A'; ①
Y = 'A';
char \*Y\_ptr = &Y; ②
Y\_ptr = &Y; ③
\*Y\_ptr = 'A' = Y; ④

※ 포인터 변수는 주소값(첫번째 Byte) 초기화
포인터 변수 Y\_ptr = 주소값 &Y ③
※ 포인터 변수는 주소값의 영향력 범위(= 주소값이 가르키는/참조하는 값/변수의 자료형 종류/크기)
주소값이 가르키는/참조하는 값/변수의 자료형 종류/크기 = char ①
포인터 변수 자료형 = Y\_ptr 의 자료형 = char \* ②
Ref) 변수의 자료형 = Y의 자료형 = char ①

#### #1-2 포인터와 포인터 변수 사용
`*변수`
포인터+변수(= 포인터+포인터 변수)
→ 포인터+포인터 변수는 포인터 변수에 초기화된 주소값이 가르키는/참조하는 값/변수
→ 포인터+포인터 변수의 반환값(Return 값)
\= 주소값이 가르키는/참조하는 값/변수
∴ `자료형`: 주소값이 가르키는값/참조하는 값/변수의 자료형
예: int, char, float

예:
char Y = 'A'; ①
Y = 'A';
char \*Y\_ptr = &Y; ②
Y\_ptr = &Y; ③
\*Y\_ptr = 'A' = Y; ④

※ 포인터 변수에 초기화된 변수의 주소값이 가르키는/참조하는 값/변수
포인터 변수 Y\_ptr 에 초기화된 변수Y의 주소값 &Y 가 가르키는/참조하는 값/변수 'A' = Y;
③ → ④(→ ①)

예:
int A = 65;
A = 65;
int \*A\_address = &A;
A\_address = &A;
\*A\_address = 65 = A;
![](https://t9003081320.p.clickup-attachments.com/t9003081320/1db7f5a8-6bd6-49ee-bde2-5e5a41c38ee1/A_address.png)

**a\_pointer\_1.c**

```perl
#include <stdio.h>

int main()
{
    int A = 65;
    int B = 66;
    int C = 67;
    int D = 68;

    // 변수의 주소값을 다른 변수에 초기화 가능
    int A_address = &A;
    int B_address = &B;
    int C_address = &C;
    int D_address = &D;

    // 출력 Error O
    printf("%d\n", *A_address);  //  65 출력?
    printf("%d\n", *B_address);  //  66 출력?
    printf("%d\n", *C_address);  //  67 출력?
    printf("%d\n", *D_address);  //  68 출력?
    // 출력 Error X
    printf("%d\n", *(&A));       //  65 출력
    printf("%d\n", *(&B));       //  66 출력
    printf("%d\n", *(&C));       //  67 출력
    printf("%d\n", *(&D));       //  68 출력

    return 0;
}


```

※ 주소값은 자료형 + 포인터 + 포인터 변수로 선언/초기화 해야함
\= 주소값은 포인터 자료형으로 선언한 포인터 변수에 초기화 해야함
`int A_address` X
`int* A_address` O
예:
int/float/char + 포인터 + 포인터 변수로 선언하지 않은 경우
int X\_ptr = &X; // int \*X\_ptr = &X;
X\_ptr = &X;
ⓐ X\_ptr 은 int 포인터 변수가 아님 = X\_ptr 의 자료형은 int \* 가 아님
→ X\_ptr 은 int 변수임 = X\_ptr 의 자료형은 int 임
※ 그래도 X\_ptr 에 일단 주소값 초기화는 가능 O
ⓑ 주소값의 영향력 범위(주소값이 가르키는/참조하는 값/변수의 자료형 종류/크기) 지정 가능 不
int \* ← X\_ptr 지정 가능 O / int ← X\_ptr 지정 가능 X
※ 하지만 ⓐ에서 초기화된 주소값이 가르키는/참조하는 동작작동 Error
∵ 포인터 변수가 아닌 일변 변수에 주소값 초기화시
일반 변수가 가르키는/참조하는 값/변수의 종류/크기 알수 없음
★ int/float/char 자료형의 일반 변수는 ⓑ 기능 無
★ array 배열 변수(포인터로 붕괴)는 ⓑ 기능 有

**a\_pointer\_2.c**

```perl
#include <stdio.h>

int main()
{
    int A = 65;
    int B = 66;
    int C = 67;
    int D = 68;

    // 포인터 자료형으로 포인터 변수 선언후 변수의 주소값 초기화
    int *A_address = &A;
    int *B_address = &B;
    int *C_address;
    int *D_address;
    C_address = &C;   // int *C_address = int* C_Address  
    D_address = &D;
    // 참조
    // int X = 10;
    // int Y;
    // Y = 20;

    printf("%d\n", *A_address);  // int *A_address = &A (A_address = &A): *A_address = (포인터 변수에 초기화된 = A_address에 초기화된) 주소값이 가르키는/참조하는 값 = 변수 A의 주소값(&A)이 가르키는 값 = 변수 A에 초기화된 값 = 65
    printf("%d\n", *B_address);
    printf("%d\n", *C_address);
    printf("%d\n", *D_address);

    printf("%d\n", *(&A));       // 65:  &A = A_address  →  *(&A) = *(A_address)
    printf("%d\n", *(&B));       // 66
    printf("%d\n", *(&C));       // 67
    printf("%d\n", *(&D));       // 68

    return 0;
}


```

※ & 변수 = 주소값
※ 포인터 변수 = & 변수 = 주소값
※ 포인터+포인터 변수(\*포인터 변수) = 주소값이 가르키는/참조하는 값/변수
※ 포인터 변수(= 주소값)보다 \*포인터 변수(= 주소값이 가르키는/참조하는 값/변수)는 한차원 ↓
\= 변수의 주소값 아래에 변수값이 초기화

#### **Feature 특징**
특징 #1
During its Lifetime
포인터 변수가 지속 기간(포인터 변수의 Lifetime)동안 다른 값/변수 가르키는것/참조하는것 가능 O
예:
포인터 변수 A\_address에 변수 A의 주소값 초기화
→ Code 진행 중 A\_address에 변수 B의 주소값 초기화 가능 O
**a\_pointer\_3.c**

```cpp
#include <stdio.h>

int main()
{
    int A = 65;
    int B = 66;

    int *A_address = &A;
    printf("%d\n", *A_address);  

    A_address = &B;
    printf("%d\n", *A_address); 

    return 0;
}


```

특징 #2
Bit Field or A Reference
int/float/char 같은 자료형의 한 종류로써 bit field/reference 자료형은 주소값 초기화 가능 X
예:
`bit field *A_address = &A;` X
`reference *A_address = &A;` X

① `bit field` 자료형
사용자가 지정한 n 비트의 자료형 (개발자가 원하는 비트수만큼 자료형 지정)

```cpp
// 선언 방법
struct 구조체 이름
{
  int 변수: Bit 수;
}
```

**a\_pointer\_4.c**

```perl
#include <stdio.h>

struct date
{
    int d : 5;  // d = 5 Bits  int 자료형
    int m : 4;  // m = 4 Bits  int 자료형
    int y;      // y = 4 Bytes int 자료형
};

int main()
{
    printf("Size of Date is %lu Bytes\n",
           sizeof(struct date));
    struct date dt = {31, 12, 2014};
    printf("Date is %d/%d/%d", dt.d, dt.m, dt.y);
    
    return 0;
}


```

② `reference` 자료형
해당 객체를 그대로 참조(= Copy) ※ C++에 존재
\= 같은 변수를 다른 이름으로 정의
\= 초기화값 동일
\= 메모리박스 동일(= 주소값이 동일)

```plain
// 선언 방법
int 변수명;
int &레퍼런스이름 = 변수명;

ex)
int X = 10;            // 변수 X
int &reference_X = X;  // reference_X = X의 레퍼런스
```

**a\_pointer\_5.c**

```cpp
#include <stdio.h>

int main()
{
    int X;                          // 변수 X
    int &reference_X = X;           // reference_X = X의 레퍼런스

    int *Pointer_X = &reference_X;  // *Pointer_X = reference_X = X 안됨

    return 0;
}


```

### #2 Pointer Variable Data Type 포인터 변수 자료형
포인터 변수에 초기화된 주소값이 가르키는/참조하는 값/변수의 자료형 + `*`
예:
int A;
int \*A\_address = &A;
char B;
char \*B\_address = &C;
float C;
float \*C\_address = &C;

포인터 변수 자료형이 필요한 이유
ⓛ 주소값의 첫번째 Bytes만 초기화 O
② 주소값의 영향력 범위(= 주소값이 가르키는/참조하는 값/변수의 자료형 종류/크기) 지정 O
By ⓛ + ②
예: 자료형이 지정되지 않을 경우
char B;
char \*B\_address = &B;
![](https://t31152436.p.clickup-attachments.com/t31152436/24f2b142-0b7b-4e9b-8d98-766ae00155fe/image1.drawio.png)
포인터 변수 B\_address가 가르키는/참조하는(= \*B\_address) 값/변수의 범위가
주소값 0x4 (1 Byte)가 아니라
주소값 0x4 ~ 0x7 (4 Bytes)가 될 수 있음
\= 실제 주소값이 가르키는/참조하는 값/변수와 상이할 수 있음

∴ 포인터 변수 자료형을 지정하지 않으면
포인터 변수에 초기화된 주소값이 가르키는/참조하는 값/변수의
메모리박스(자료형) 크기를 파악할 수 없음
\= 실제 주소값이 가르키는/참조하는 값/변수가 상이할 수 있음

**b\_pointer\_data\_type\_1.c**

```perl
#include <stdio.h>

int main()
{
    int A = 65;
    char B = 'X';
    float C = 8.625;

    int *A_address;   
    char *B_address;  
    float *C_address; 
    A_address = &A;
    B_address = &B;
    C_address = &C;

    printf("&\n");                       // Winbow OS:  C: 15 ~ 18까지 주소 출력 X   
    printf("A 주소값: %d\n", &A);        // A:  20~23  
    printf("B 주소값: %d\n", &B);        // B:  19   
    printf("C 주소값: %d\n", &C);        // C: (16~18 3 Bytes 공백) 12~15  ∵  CPU는 int 정수(4 Bytes)를 기반으로 작동  → 4 Bytes씩 메모리박스 형성 편의            
                                                                                                          
    printf("&\n");
    printf("A 주소값: %d\n", A_address);
    printf("B 주소값: %d\n", B_address);
    printf("C 주소값: %d\n", C_address);

    printf("*\n");
    printf("A_address 포인터 변수가 가르키는 값: %d\n", *A_address);  // A_address에 초기화된 값이 20~23 까지 주소값이며, 그 초기화된 주소값이 가르키는 값
    printf("B_address 포인터 변수가 가르키는 값: %c\n", *B_address);  // B_address 초기화된 값이 19 주소값이며, 그 초기화된 주소값이 가르키는 값
    printf("C_address 포인터 변수가 가르키는 값: %f\n", *C_address);  // B_address 초기화된 값이 12~15 까지 주소값이며, 그 초기화된 주소값이 가르키는 값

    return 0;
}


```

![](https://t9003081320.p.clickup-attachments.com/t9003081320/c85acca7-284f-4692-b400-5c751f8090bb/Picture1.png)

### #3 Pointer Variable to Variable Value Change 포인터 변수 사용 → 변수값 변경
포인터 변수가 가르키는/참조하는 값을 변경하여 기존 초기화된 값을 변경할 수 있음

**b\_pointer\_data\_type\_2.c**

```perl
#include <stdio.h>

int main()
{
    int A = 65;
    char B = 'X';
    float C = 8.625;

    int *A_address;   
    char *B_address;  
    float *C_address; 
    A_address = &A;
    B_address = &B;
    C_address = &C;

    printf("A_address 포인터 변수가 가르키는 값: %d\n", *A_address);  
    printf("B_address 포인터 변수가 가르키는 값: %c\n", *B_address);  
    printf("C_address 포인터 변수가 가르키는 값: %f\n", *C_address);  
    printf("==============================================\n");

    *A_address = 66;      // *A_address에 초기화된 주소값(&A)가 가르키는/참조하는 값  65를 66으로 변경 
    *B_address = 'Y';
    *C_address = 0.625;

    printf("A_address 포인터 변수가 가르키는 값: %d\n", *A_address);  
    printf("B_address 포인터 변수가 가르키는 값: %c\n", *B_address);  
    printf("C_address 포인터 변수가 가르키는 값: %f\n", *C_address); 
    printf("==============================================\n");

    printf("변경된 A값: %d\n", A);
    printf("변경된 B값: %c\n", B);
    printf("변경된 C값: %f\n", C);

    return 0;
}


```

### #4 Pointer Variable Size 포인터 변수 크기
포인터 변수 크기(= 주소값이 초기화된 메모리박스 크기)는 자료형과 관계 X
\= 포인터 변수가 가르키는/참조하는 값/변수의 자료형의 크기와 관계 X
포인터 변수 크기(= 주소값이 초기화된 메모리박스 크기)는 PC OS에 관계 O
*   Past-Time

32 Bits OS: 32 Bits(= 4 Bytes)

→ 포인터 변수(= 주소값 자체) 크기 = 4 Bytes

*   Current-Time

64 Bits OS: 64 Bits(= 8 Bytes)

→ 포인터 변수(= 주소값 자체) 크기 = 8 Bytes

예:
32 Bits OS
![](https://t31152436.p.clickup-attachments.com/t31152436/2fb41e6a-2299-4e33-8dad-8f75347669cb/image3.drawio.png)

예:
64 Bits OS
![](https://t31152436.p.clickup-attachments.com/t31152436/5a2831ad-94e7-4bf0-9e8c-74132f306f73/image2.drawio.png)

**b\_pointer\_data\_type\_3.c**

```cpp
#include <stdio.h>

int main()
{
    int *A_address;
    char *B_address;
    float *C_address;

    printf("A_address 포인터 변수의 크기: %d Bytes\n", sizeof(A_address));
    printf("B_address 포인터 변수의 크기: %d Bytes\n", sizeof(B_address));
    printf("C_address 포인터 변수의 크기: %d Bytes\n", sizeof(C_address));

    return 0;
}


```

**b\_pointer\_data\_type\_4.c**

```perl
#include <stdio.h>

int main()
{
    int A = 65;
    char B = 'X';
    float C = 8.625;

    int *A_address;
    char *B_address;
    float *C_address;
    A_address = &A;
    B_address = &B;
    C_address = &C;

    printf("A_address 포인터 변수의 크기: %d Bytes\n", sizeof(A_address));
    printf("B_address 포인터 변수의 크기: %d Bytes\n", sizeof(B_address));
    printf("C_address 포인터 변수의 크기: %d Bytes\n", sizeof(C_address));
    printf("===========================================\n");

    printf("A의 주소: 0x%p\n", &A);
    printf("B의 주소: 0x%p\n", &B);
    printf("C의 주소: 0x%p\n", &C);
    printf("===========================================\n");

    printf("A_address의 주소: 0x%p\n", &A_address);
    printf("B_address의 주소: 0x%p\n", &B_address);
    printf("C_address의 주소: 0x%p\n", &C_address);
    printf("===========================================\n");

    printf("A 주소값 - B 주소값 크기: %d\n", (int)&A - (int)&B);
    printf("B 주소값 - C 주소값 크기: %d\n", (int)&B - (int)&C);                   // Winbow OS:  ∵ 변수 주소값 차이 4 Bytes씩 메모리박스 형성 편의
    printf("C 주소값 - A_address 주소값 크기: %d\n", (int)&C-(int)&A_address);     // Winbow OS:  ∵ 포인터변수 주소값 차이 8 Bytes씩 메모리박스 형성 편의
    printf("A_address 주소값 - B_address 주소값 크기: %d\n", (int)&A_address-(int)&B_address);
    printf("B_address 주소값 - C_address 주소값 크기: %d\n", (int)&B_address-(int)&C_address);
    printf("===========================================\n");

    return 0;
}


```

### #5 Pointer Variable ± Operation 포인터 변수 ± 연산

#### 개념)
사칙연산 (+ – \* /)
연산 객체 "**단위"**만큼 + – \* /
예:
2 \+ 3 = 5
*   2: 10진수
*   \+ 3: 10진수 단위에서 3만큼 증가
*   \= 5: 10진수 2에 10진수 단위로 3만큼 증가한 값

∴
포인터 변수 +1 = 포인터 변수가 가르키는 값의 자료형의 크기만큼 +
포인터 변수 \-1 = 포인터 변수가 가르키는 값의 자료형의 크기만큼 -
⇒
포인터 변수가 가르키는/참조하는 값의 자료형의 크기
*   포인터 변수는 ⓛ 주소값의 첫번째 Bytes만 초기화 O
*   포인터 변수는 ② 주소값의 영향력 범위 지정 O

\= 주소값이 가르키는/참조하는 값/변수의 자료형 종류/크기

\= ⓛ + ②
예:
int A = 65;
A = 65;
int \*A\_address = &A;
A\_address = &A;
A\_address = 0x0
A\_address +**1** = 0x**4** // **4** = &A가 저장된 포인터 변수가 가르키는 값의 자료형 크기 1번 더하기
A\_address +**2** = 0x**8** // **8** = &A가 저장된 포인터 변수가 가르키는 값의 자료형 크기 2번 더하기
Ref)
int ±4 Bytes
char ±1 Byte
float ±4 Bytes

#### 풀이)
※ 포인터 변수(= 주소값)의 크기
\= 8 Bytes (64 Bits OS)
★ 일반 변수 주소값이 초기화된 포인터 변수의 메모리박스 크기 = 8 Bytes

※ 포인터 변수(= 주소값)의 연산(예: ± 1)
\= 일반 변수 주소값 ± 1
\= 일반 변수 주소값
± 일반 변수 주소값이 가르키는/참조하는 값/변수의 메모리박스 크기
(int/float ±4 or char ±1)
\= 일반 변수 주소값
± 포인터 변수 자료형이 가르키는/ 참조하는 값/변수의 크기
(int\* float\* char\*) (int/float ±4 or char ±1)
\= 주소값
± 변수 자료형 크기
(int/float ±4 or char ±1)
↓ 한차원 아래
※ \*포인터 변수(= 주소값이 가르키는/참조하는 값/변수)의 연산(예: ± 1)
\= 일반 변수 주소값이 가르키는/참조하는 값 ± 1
\= 일반 변수값 ± 1

※※※
포인터 변수 ± int n
\= 일반 변수 주소값 ± 일반 변수 주소값이 가르키는/참조하는 값/변수의 메모리박스 크기 x n
\= 일반 변수 주소값 ± 포인터 변수 자료형이 가르키는/ 참조하는 값/변수의 크기 x n
\= 일반 변수 주소값 ± (변수 자료형의 크기 x n)
↓ 한차원 아래
\*포인터 변수 ± int n
\= 일반 변수값 ± int n

**b\_pointer\_data\_type\_5.c**

```perl
#include <stdio.h>

int main()
{
    int A = 65;
    char B = 'X';
    float C = 8.625;

    int *A_address;
    char *B_address;
    float *C_address;
    A_address = &A;
    B_address = &B;
    C_address = &C;

    printf("\n===포인터 변수 연산===\n");
    printf("A_address 값: %d\n", A_address);
    for (int i = 0; i < 5; i++)
    {
        printf("A_address +%d: %d\n", i, A_address + i);
    }
    printf("=====================\n");

    printf("B_address 값: %d\n", B_address);
    for (int i = 0; i < 5; i++)
    {
        printf("B_Address +%d: %d\n", i, B_address + i);
    }
    printf("=====================\n");

    printf("C_address 값: %d\n", C_address);
    for (int i = 0; i < 5; i++)
    {
        printf("C_Address +%d: %d\n", i, C_address + i);
    }

    printf("\n==*포인터 변수 연산==\n");
    for (int i = 0; i < 5; i++)
    {
        printf("*A_address +%d: %d\n", i, *A_address + i);
    }
    printf("=================\n");

    printf("*B_address 값: %d\n", *B_address);
    for (int i = 0; i < 5; i++)
    {
        printf("*B_Address +%d: %d\n", i, *B_address + i);
    }
    printf("=================\n");

    printf("*C_address 값: %f\n", *C_address);
    for (int i = 0; i < 5; i++)
    {
        printf("*C_Address +%d: %f\n", i, *C_address + i); 
    }

    return 0;
}


```

### #6 Pointer Variable & Variable Use: General 포인터 변수 & 변수 사용
####   

#### #6-1 General 일반
**b\_pointer\_data\_type\_6a.c**

```cpp
#include <stdio.h>

int main()
{
    int A = 65;
    int B = 66;

    int *A_address = &A;
    *A_address = 88;
    printf("%d\n", *A_address);  

    A_address = &B;
    printf("%d\n", *A_address); 

    return 0;
}


```

#### #6-2 Function 함수
**b\_pointer\_data\_type\_6b.c**

```cpp
#include <stdio.h>

void function_1(int *A)        // int A = int *X_ptr_1 = int &X                     
{
    printf("%d\n", A);         // A = &X  
    printf("%d\n", *A);        // *A = *(&X) = 5
}

void function_2(int *A_ptr_1)  // int *A_ptr_1 = int *X_ptr_1 = int &X                                
{
    printf("%d\n", A_ptr_1);   // A_ptr_1 = X_ptr_1 = &X  
    printf("%d\n", *A_ptr_1);  // *A_ptr_1 = *(X_ptr) = *(&X) = 5
}

int main()
{
    int X = 5;
    int *X_ptr_1 = &X;         //  X_ptr_1 = &X          

    function_1(&X);
    function_2(X_ptr_1);           
 
    return 0;
}


```

※ 포인터 변수 = 주소값

|  | 변수 int char float |
| ---| --- |
| 사용자정의 함수 | 매개변수<br>int \* A<br>A = &X<br><br>매개변수<br>int \* A\_ptr\_1<br>A\_ptr\_1 = X\_ptr\_1<br><br>※ A = A\_ptr\_1<br>※ 자료형<br>int \* |
| ↑ | ↑ |
| 메인 함수 | 인수<br>&X = X\_ptr\_1 |

### #7 Multiple Pointer Variable 다중 포인터 변수

선언
\*++ → 한차원 ↑
사용
\*++ → 한차원 ↓

#### #7-1 이중 포인터 변수
**b\_pointer\_data\_type\_7a.c**

```perl
#include <stdio.h>

int main() 
{      
       int A = 5;
       int *A_address_1 = &A;
       int **A_address_2 = &A_address_1;

       printf("=====선언=====\n");      // *++  →  한차원 ↑
       printf("%d\n", A_address_1);
       printf("%d\n", A_address_2);

       printf("=====사용=====\n");      // *++  →  한차원 ↓
       printf("%d\n", *A_address_1);
       printf("%d\n", *A_address_2);
       printf("%d\n", **A_address_2);

       return 0; 
}


```

![](https://t9003081320.p.clickup-attachments.com/t9003081320/b0ded5bd-ea2b-4ca9-bb23-c62be981a269/Picture2.png)

#### #7-2 삼중 포인터 변수
**b\_pointer\_data\_type\_7b.c**

```perl
#include <stdio.h>

int main() 
{      
       int A = 5;
       int *A_ptr_1 = &A;
       int **A_ptr_2 = &A_ptr_1;
       int ***A_ptr_3 = &A_ptr_2;

       printf("=====선언=====\n");      // *++  →  한차원 ↑
       printf("%d\n", A_ptr_1);
       printf("%d\n", A_ptr_2);
       printf("%d\n", A_ptr_3);
       printf("%d\n", &A_ptr_3);

       printf("=====사용=====\n");      // *++  →  한차원 ↓
       printf("%d\n", *A_ptr_1);
       printf("%d\n", *A_ptr_2);
       printf("%d\n", **A_ptr_2);
       printf("%d\n", *A_ptr_3);
       printf("%d\n", **A_ptr_3);
       printf("%d\n", ***A_ptr_3);

       return 0; 
}


```

![](https://t9003081320.p.clickup-attachments.com/t9003081320/eae87610-54d0-458b-bcbb-cccf6a26cc4a/Picture3.png)

#### ★ int float char 정수 소수 문자
※ & 변수 = 주소값
※ 포인터 변수 = & 변수 = 주소값
※ 포인터+포인터 변수(\*포인터 변수) = 주소값이 가르키는/참조하는 값/변수
※ 포인터 변수(= 주소값)보다 \*포인터 변수(= 주소값이 가르키는/참조하는 값/변수)는 한차원 ↓
\= 변수의 주소값 아래에 변수값이 초기화
※ 포인터 변수 연산
포인터 변수 ± int n
\= 일반 변수 주소값 ± 포인터 변수 자료형이 가르키는/ 참조하는 값/변수의 크기 x n
\* 포인터 변수 ± int n
\= 일반 변수 주소값이 가르키는/참조하는 값 ± int n

※ 선언
\*++ → 한차원 ↑
※ 사용
\*++ → 한차원 ↓
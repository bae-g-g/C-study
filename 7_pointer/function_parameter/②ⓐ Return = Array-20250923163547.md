# ②ⓐ Return = Array

## **① Return Array 배열 반환**

Return ("Static" 정적변수 + 포인터변수)
⇒ DATA Sector "할당" = Compile 시 할당
⇒ Life Cycle Memory 할당된 Code Block 시작 ~ Programme 종료 (Code Block 종료 X)

❶ 배열(➝붕괴➝포인터변수: 배열에서 붕괴된 포인터변수)은 함수의 Return (반환)으로 사용 X
*   Compiling Error #1: 배열 재초기화 불가능

(Return = 다른 함수 변수 재초기화) ➝(배열 적용)➝ (Return = 다른 함수 배열 재초기화)

E.g.)

int A\[3\] = {1, 2, 3};

int B\[3\] = A; Compiling Error

*   Compiling Error #2: C언어 없는 기능 설정

배열 크기가 너무 크면 함수에서 처리시 너무 비효율적이므로 없는 기능 설정

int\[ \] function ( ) // Compiling Error O
{
return int\[ \]
}
int main ( )
{
}

❷ 포인터변수(주소값)로 함수의 Return (반환)으로 사용 O
(上 Compiling Error #1 + #2) + (큰변수 e.g. 배열, 구조체, 클라스에는 주소값으로 접근성 용이)

int\* function ( ) // Compiling Error X
{
return int\*
}
int main ( )
{
}

**return\_array\_1.c**
"Auto" (e.g. Local Variable 지역변수) + 포인터변수
⇒ STACK Sector "할당" = Run Time 시 할당 (Code Block 실행 중 할당)
⇒ Life Cycle 사용자정의 함수 실행 ~ 사용자정의 함수 종료
①A 배열에서 붕괴된 포인터변수 반환 가능 X

E.g.) return X; // int X\[3\] = {1, 2, 3}; : X ➝(붕괴 O)➝ &X\[0\]

➝ 0 반환

∵ Compiling Error #1: 배열 재초기화 불가능

(Return ➝ 다른 함수 변수 재초기화) ➝(배열)➝ (Return ➝ 다른 함수 배열 재초기화)

\= Compiling Error O

E.g.)

int A\[3\] = {1, 2, 3};

int B\[3\] = A; //  Compiling Error O

∵ Compiling Error #2: C언어 없는 기능 설정

배열 크기가 너무 크면 함수에서 처리시 너무 비효율적이므로 없는 기능 설정

\= Compiling Error O

①B 포인터변수 반환 가능 O

E.g.) return X\_ptr; // int X\[3\] = {1, 2, 3}; : int \*X\_ptr = &X\[0\];

② 사용 범위가 지역 변수 (함수 내)
③ Life Cycle이 사용자정의 함수 종료후 포인터변수 Memory "해제"
i.e. ①AB + ② + ③

사용자정의 함수 종료후

해당 Memory 공간에 다른 변수/함수 (e.g. 반복문 int i , printf) "할당" 확율 있음

∵ Stack Sector 메모리 "할당" 원리(쌓임) 특성
∴ 사용자정의 함수 Return (반환)한 포인터변수(주소값)으로 접근한 메모리 공간

≠ 배열 메모리 공간

本 의도한 초기화값 (e.g. 배열 요소 값)
≠ 실제 배열 메모리 공간에 초기화된 값 (e.g. 사용자정의 함수 호출 아래 i 값, printf 주소값)

```plain
// Case #1A:  일반 변수 Return
#include <stdio.h>

int add_10(int variable)
{
   return variable + 10; // (Step 1): variable + 10 = 0 + 10 ➝ return 10
                         // (Step 2): return = 사용자정의 함수 종료
                         // (Step 3): variable 메모리 해제
}

int main()
{
   int X = 0;

   X = add_10(X);

   printf("X: %d\n", X);

   return 0;
}


// Case #1B:  일반 포인터변수 Return
#include <stdio.h>

int *add_1(int *variable_ptr)
{
   return variable_ptr + 1;  // (Step 1): variable_ptr + 1 = variable_ptr + variable_ptr이 가르키는 값의 자료형의 크기 = X 주소값 + 4 Bytes = X 오른쪽 옆변수 주소값 = Y 주소값 
                             // (Step 2): return = 사용자정의 함수 종료
                             // (Step 3): variable_ptr 메모리 해제
}

int main()
{
   int Y = 10;
   int X = 0;
   printf("&X: %d\n", &X);
   printf("&Y: %d\n", &Y); 

   int *X_ptr = &X;
   
   int *Y_ptr = add_1(X_ptr);

   printf("*X_ptr: %d\n", *X_ptr);
   printf("*Y_ptr: %d\n", *Y_ptr);    

   return 0;
}


// Case #2A:  배열 변수 Return
#include <stdio.h>

int *array_return()
{
   int array[10];
   printf("array: %d\n", array);

   for (int i = 0; i < 10; ++i)
   {
      array[i] = i + 1;
   }

   printf("%d\n", array);

   return array; // (Step 1): 배열 array (➝붕괴➝ 포인터 변수: 배열에서 붕괴된 포인터변수 array 0번째 주소값 &array[0])
                 //           1) 배열(➝붕괴➝포인터변수:  배열에서 붕괴된 포인터변수) 반환 X
                 //           2) 배열(크기가 너무 크면 함수에서 처리시 비효율적이기 때문에) 반환 없는 기능 설정
                 //           결과:  주소값 0 반환 (무엇을 반환할지 컴퓨터가 몰라 0을 반환  ➝  이유 ?!?!?) 
                 // (Step 2): return = 사용자정의 함수 종료
                 // (Step 3): 배열 array 메모리 해제  ➝  주소값 0 
}

int main()
{
   int int_array[10]; 
   int *int_ptr;      // 배열의 주소를 저장할 포인터 변수
   int arr_size;      // 배열의 크기를 저장할 변수
   printf("int_array: %d\n", int_array);

   int_ptr = array_return(); // 반환된 배열(➝붕괴➝ 배열의 0번째주소)을 int_ptr에 저장
   //    int_array = array_return(); // 배열은 선언 이후에 (배열 전체) 초기화 불가 ➝ Compiling Error
   printf("%d\n", int_ptr);

   for (int i = 0; i < 10; i++)
   {
      printf("*(int_ptr + %d) : %d\n", i, *(int_ptr + i));  // 주소값 0이 가르키는 값 ?!?!?! ➝ Segmentation Fault: 가르킬 권한이 없음
   }

   return 0;
}


// Case #2B:  배열 포인터변수 Return
#include <stdio.h>

int *array_return()
{
   int array[10];
   int *array_ptr = array;
   printf("array: %d\n", array);

   for (int i = 0; i < 10; ++i)
   {
      array[i] = i + 1;
   }
   
   printf("%d\n", array);

   return array_ptr; // (Step 1): 포인터 변수 array 0번째 주소값 &array[0]
                     // (Step 2): return = 사용자정의 함수 종료
                     // (Step 3): 포인터 변수 array_ptr 메모리 해제
}

int main()
{
   int int_array[10]; 
   int *int_ptr;      
   int arr_size;
   printf("int_array: %d\n", int_array);      

   int_ptr = array_return();
   printf("%d\n", int_ptr);

   for (int i = 0; i < 10; i++)
   {
      printf("*(int_ptr + %d) : %d\n", i, *(int_ptr + i)); 
   }

   return 0;
}


```

*   Auto 일반 변수

Return 작동 O

*   Auto 일반 포인터변수

Return 작동 O

*   Auto 일반 배열 변수

Return 작동 X (e.g. 0 반환)

*   Auto 일반 배열 포인터변수
Return 작동 O

But, 배열 Memory는 각 배열 요소 메모리의 String

➝ 사용자정의 함수 종료후

해당 배열 Memory에 다른 변수/함수 (e.g. 반복문 int i , printf) "할당" 확율 있음

➝ 本 의도한 초기화값 (e.g. 배열 요소 값)

≠ 실제 배열 Memory에 초기화된 값 (e.g. 사용자정의 함수 호출 아래 i 값, printf 주소값)

⇓
Solution #1

**return\_array\_2.c**
"Static" 정적변수 + 포인터변수 ⇒ Stack Sector
⇒ DATA Sector "할당" = Compile 시 할당 (Run Time시 RAM에 복사/할당 실행)
⇒ Life Cycle 변수 선언된 Code Block 시작 ~ Programme 종료 (Run Time 중 계속 유지)
① 포인터변수 반환 가능 O
② 사용 범위가 지역 변수 (함수 내)
③ Life Cycle이 사용자정의 함수 종료후 포인터변수 Memory "유지"
i.e. ① + ② + ③

사용자정의 함수가 종료되어도

Life Cycle이 유지되는 Static 정적변수로 포인터변수(주소값)을 Return (반환)하여

메인 함수의 배열에 접근 가능 O

∴ 사용자정의 함수 Return (반환)한 포인터변수(주소값)으로 접근한 메모리 공간

\= 배열 메모리 공간

本 의도한 초기화값 (e.g. 배열 요소 값)

\= 실제 배열 메모리 공간에 초기화된 값 (e.g. 배열 요소 값)

Ref) 큰변수(e.g. 배열, 구조체, 클라스) + static 포인터변수 사용 의의

변수의 크기가 크기 때문에 변수 전체를 사용하기 보다 주소값만으로 접근함이 용이

```cpp
#include <stdio.h>

int *array_return()
{
   static int array[10];

   for (int i = 0; i < 10; ++i)
   {
      array[i] = i + 1;
   }

   return array;      // 배열 array을 포인터변수 &array[0]로 리턴 가능   ∵  array를 static 변수 자료형으로 선언하여 14번째줄 이후(사용자정의 함수 종료후)에도 Life Cycle 유지
}

int main()
{
//    int int_array[10]; // 배열 "전체"는 선언후 초기화 불가 ➝ 21 번째줄 실행 불가로써, 20번째줄에서 함수호촐 ➝ 3~13번째줄 사용자정의함수에서 (static 변수 선언 + 포인터변수로 반환)으로 작성 필요 없음
   int *int_ptr;      // 배열 선언 생략하고 배열의 주소를 저장할 포인터변수만 선언

   int_ptr = array_return();  // 배열의 주소를 int_ptr에 저장
//    int_array = array_return(); // 배열은 선언 이후에 초기화 불가 ➝ 컴파일 에러
   for (int i = 0; i < 10; i++)
   {
      printf("*(int_ptr + %d) : %d\n", i, *(int_ptr + i));
   }

   return 0;
}


```

**return\_array\_3.c**
Static" 정적변수 + Array Size 배열 크기

```plain

#include <stdio.h>

int *array_return(int size)
{
   static int array[10000];                 
   for (int i = 0; i < size; ++i)
   {
      array[i] = i + 1;
   }

   return array;           
}

int main()
{
   int *int_ptr;           
   int arr_size;                            
   scanf("%d", &arr_size);

   int_ptr = array_return(arr_size); 

   for (int i = 0; i < arr_size; i++)
   {
      printf("*(int_ptr + %d) : %d\n", i, *(int_ptr + i));
   }
   printf("arr size : %d", arr_size);

   return 0;
}




```

+
Solution #2

**return\_array\_4.c**
Dynamic Memory Allocation
⇒ HEAP Sector "할당" (느슨한 PRIORTY QUEUE 방식)
\= Run Time 시 할당 (Programme 실행 중 할당)
⇒ Life Cycle 변수 선언된 Code Block 시작 ~ Programme 종료 (Run Time 중 계속 유지)
사용자가 직접 할당하는 함수(malloc, calloc, relloc)의 Return (반환)
\= 포인터변수(주소값)
① 포인터변수 반환 가능 O
② 사용 범위가 지역 변수 (함수 내)
③ Life Cycle이 사용자정의 함수 종료후 포인터변수 Memory "유지"
i.e. ① + ② + ③

사용자정의 함수가 종료되어도

Life Cycle이 유지되는 Static 정적변수로 포인터변수(주소값)을 Return (반환)하여

메인 함수의 배열에 접근 가능 O

∴ 사용자정의 함수 Return (반환)한 포인터변수(주소값)으로 접근한 메모리 공간

\= 배열 메모리 공간

本 의도한 초기화값 (e.g. 배열 요소 값)

\= 실제 배열 메모리 공간에 초기화된 값 (e.g. 배열 요소 값)

Ref) 큰변수(e.g. 배열, 구조체, 클라스) + static 포인터변수 사용 의의

변수의 크기가 크기 때문에 변수 전체를 사용하기 보다 주소값만으로 접근함이 용이

```plain

#include <stdio.h>

int *array_return(int size)
{
   int *array = malloc(size * sizeof(int));  // malloc 함수의 Parameter에 할당하고 싶은 메모리박스의 전체 Byte 크기 입력 = size * 4 
                                             // malloc 함수의 Return 값은 생성된 메모리박스의 주소값
                                             // E.g.) 29번째줄 arr_size = 10 초기화
                                             //       array = (10 * 4 Bytes =) 40 Bytes 크기의 메모리박스 주소값

   for (int i = 0; i < 10; ++i)
   {
      array[i] = i + 1;
   }

   return array;                             
}

int main()
{
   int *int_ptr;      
   int arr_size;                           
   scanf("%d", &arr_size);

   int_ptr = array_return(arr_size); 
   for (int i = 0; i < 10; i++)
   {
      printf("*(int_ptr + %d) : %d\n", i, *(int_ptr + i));
   }
   printf("arr size : %d", arr_size);

   return 0;
}




```

**※ Summary #1 - Return Array 배열 반환 (1)**
배열은 Return (반환) 불가
배열의 주소값을 초기화한 포인터변수로 Return (반환) 해도 Auto 포인터변수는 오류를 발생시킴
**∵** 사용자정의 함수 종료시 Memory "해제"
∴ Static 정적 포인터변수 or Dynamic Memory Allocation 동적 메모리 할당 이용
**∵** 사용자정의 함수 종료시 Memory "유지"

| Return 배열 (➝붕괴➝ 포인터 변수)<br>Return X (➝붕괴➝ &X\[0\]) | 배열(➝붕괴➝포인터변수) 반환 가능 X<br>E.g.) 0 반환<br> |
| ---| --- |
| Return Auto 포인터변수 | 포인터변수(주소값) 반환 가능 O<br><br>사용자정의 함수 종료시<br>포인터변수 Memory "해제"<br>➝ 배열 요소 의도값<br>≠ 실제 초기화값<br> |
| ⇓ Solution |
| Return Static 포인터변수<br><br>Return Dynamic Memory Allocation 포인터변수 | 포인터변수(주소값) 반환 가능 O<br><br>사용자정의 함수 종료시<br>포인터변수 Memory "유지"<br>➝ 배열 요소 의도값<br>\= 실제 초기화값<br> |
| ★ 장/단점 비교후 Programme에 맞게 Static or Dynamic Memory Allocation 사용<br>\- Static = "정적" ➝ 사전 정해진 설계<br>\- Dynamic Memory Allocation = "동적" ➝ 유동적 변화 설계 |

**※ Summary #2 - Priority of Auto/Static/Dynamic Memory Allocation in General Use**

*   Priority #1 Auto

가능하면 Auto 변수 사용

∵ 함수 시작 ~ 종료 = 자동 Memory "할당"/"해제"

*   Priority #2 Static vs Dynamic Memory Allocation
장/단점 비교후 Programme에 맞게 Static or Dynamic Memory Allocation 사용
\- Static = "정적" ➝ 사전 정해진 설계
\- Dynamic Memory Allocation = "동적" ➝ 유동전 변화 설계
# Usage #3

# **Usage #3 용도 #3**

## **Concept 개념**

**Call Back Function 콜백 함수**
메인 함수 내 함수 foo 호출의 인자인 함수 포인터 변수를
함수 foo의 매개 변수로 전달할 때,
그 매개 변수에 해당하는 함수 포인터 변수에 해당하는 함수
\= 콜백 함수

※ 콜백 함수
≒ 콜백 함수 주소값
\= 메인 함수 내 함수 foo 호출의 인자
\= 함수 foo의 매개 변수

**func\_cb\_1.c**

```cpp
콜백 함수(  )
{

}

function foo (매개변수 = 콜백 함수 주소값)
{
   콜백 함수 실행 코드 // 콜백 함수의 주소값을 사용하는 코드 포함
}


메인 함수
{

  foo (인자 = 콜백 함수 주소값);

}


```

Call Back Function 콜백 함수 `≒(=)` Call Back 콜백
➝ 本 "콜백 함수"를 "콜백"으로 사용
Cf) 유사 개념: 포인터 변수 ≒(=) 포인터

ⓐ 本 콜백 함수
\= 메인 함수 내 함수 foo 호출의 인자로 함수 foo의 매개 변수에 전달되는 함수
≒ 콜백 함수 주소값
\= 메인 함수 내 함수 foo 호출의 인자
\= 함수 foo의 매개 변수
↓

ⓑ 化 콜백 함수
콜백 함수를 어떤 이벤트 완료후 실행하는 함수로 "주로" 개발
➝ 콜백 함수의 여러 기능 중 어떤 이벤트 완료후 실행하는 것이 대표 기능이 됨

∴
ⓒ 化 콜백 함수 ≒(=) 콜백
\= 콜백이 어떤 이벤트 완료 후 실행하는 개념이 범관용적으로 됨

## **Example 예시**
**API ➝ Call Back API**

**① API (Application Programming Interface)**
ⓐ 실질적 정의

프로그램 간에 서로 정보를 주고 받는 통신 하는 방법

ⓑ 사전적 정의

프로그램 간에 서로 정보를 주고 받기 위한 인터페이스

*   사전에 만들어져 있는 프로그램/시스템
*   다른 개발자들이 접근/사용 할 수 있는 프로그램/시스템
E.g.)
*   서버 개발자 A가 서버 프로그램 개발

프로그램 내에 데이터(e.g. 텍스트, 이미지 등) 요청하는 API 빌드

*   서버 개발자 B가 웹 프로그램(e.g. 크롬) 개발

프로그램 내에 서버에 있는 데이터를 전송 받아 웹 화면에 로딩

Ref)

웹 프로그램에 API를 실행하는 코드 빌드

E.g.)

HTTP GET [http://www.appdomain.com/users?size=20&page=5](http://www.appdomain.com/users?size=20&page=5) 를

웹 프로그램에 API를 실행 하는 코드

![](https://t9018093303.p.clickup-attachments.com/t9018093303/c632db89-41aa-4b9e-b807-0a8ab08eabad/image.png)

*   서버로 데이터 요청

웹 프로그램에서 데이터 수신

Ref)

수신되는 값 = 웹 프로그래밍에서 처리하는 데이터

e.g.) HTML, CSS, JAVA SCRIPT = 텍스트 O, 프로그래밍 언어 X (∵ 컴파일 실행 X)

![](https://t9018093303.p.clickup-attachments.com/t9018093303/9b4eac72-9c00-4f05-a710-d103003e8599/image.png)

Ref)
웹 프로그래밍 (e.g. JAVA, PHP)
개발자가 수신값을 Parsing(해부) 등의 작업 후
화면에 Displaying 작업 수행

*   웹 프로그래밍 실행 결과

수신된 데이터를 웹 프로그램에서 시간/위치에 맞게 Display 함

**② Call Back API (Call Back Application Programming Interface)**
ⓐ 실질적 정의

콜백(어떤 이벤트 후 실행하는 함수) 기반 프로그램 간에 서로 정보를 주고 받는 통신 하는 방법

ⓑ 사전적 정의

콜백(어떤 이벤트 후 실행하는 함수) 기반 프로그램 간에 서로 정보를 주고 받기 위한 인터페이스

*   콜백 기능을 하는 사전에 만들어져 있는 프로그램/시스템
*   다른 개발자들이 접근/사용 할 수 있는 프로그램/시스템 중 콜백 기능 장착

E.g.)
http API (서버 API) 중
Web Hook 웹 훅 (이벤트 종료 후, "서버에 요청"을 실행) 기능을
Call Back 콜백을 통해 실행하는 API
Cf)
콜백
ⓐ≠ 다른 함수 A의 인자로 다른 함수 B의 매개 변수에 전달되는 함수
매개변수로 함수를 다른 함수에 전달
함수와 함수와의 통신
ⓑ≠ 어떤 이벤트를 완료후 실행하는 함수
어떤 이벤트를 완료후 실행하는 매개변수로 함수를 다른 함수에 전달
어떤 이벤트를 완료후 실행하는 함수와 함수와의 통신
ⓒ= 어떤 이벤트를 완료후 실행
프로그램과 프로그램과의 통신
e.g.)
프로그램 A (C 언어) -------------------------- 프로그램 B (파이썬)
⒜ 프로그램 A의 함수를 콜백 기능 ⓐ≠, ⓑ≠에 의해 B로 전달 가능 X
⒝ 프로그램 A를 콜백 기능 ⓒ=에 의해 B로 전달 가능 O

**Case #1) 콜백 기능 웹 훅 사용 X**
*   결제 프로세스 시작

쿠팡 서버 ➝ 토스 서버: 결제요청 전달

*   결제 확인

쿠팡 서버 ➝ 토스 서버: (0.1초 후) 결제완료 True/False 확인

토스 서버 ➝ 쿠팡 서버: 결제 미완료 응답

쿠팡 서버 ➝ 쿠팡 서버: (0.1초 후) 결제완료 True/False 확인

토스 서버 ➝ 쿠팡 서버: 결제 미완료 응답

...

(반복)

...

*   결제 완료

쿠팡 서버 ➝ 토스 서버: (0.1초 후) 결제완료 True/False 확인

토서 서버 ➝ 쿠팡 서버: 결제 완료 응답

**Case #2) 콜백 기능 웹 훅 사용 O**
*   결제 프로세스 시작

쿠팡 서버 ➝ 토스 서버: 결제요청 + "결제 완료 후" 응답 받을 쿠팡 서버 주소 한번에 전달

콜백 기능 ⓒ= 사용

∴ Case #1)의 결제 확인 과정 생략 가능 O

*   결제 처리

토서 서버 결제 처리: 쿠팡 서버 -------------- 토스 서버 간의 통신 無

*   결제 완료

토스 서버 ➝ 쿠팡 서버: 결제 완료 응답

| **Case #2) 콜백 기능 사용 O**<br>콜백 기능 사용 장점 | **Case #1) 콜백 기능 사용 X**<br>콜백 기능 사용 단점 |
| ---| --- |
| 데이터 송신을 여러번 할 필요 X | 중간에 문제 발생시 처리 용이 X |
| Case #1)의 결제 확인 과정 생략 가능 O<br>➝ 비용 절약<br><br>Cf)<br>시간 절약 측면은 명확 X<br>서버 간의 통신 無 시간 > Case #1)의 결제 확인 과정<br>의 확율도 무시 못함<br><br>Cf)<br>콜백 기능 단점 보완책 예시<br>10초 후 다시 실행 시간 소요 발생<br>Case #1)에서는 0.1초 후 바로 실행 | 토서 서버 문제 발생 시<br>쿠팡 서버 무한 대기<br>∴ 10초 후 다시 실행 요청 기능 필요 |

## **Feature 특징**

ⓐ
콜백 함수 자료형 = 인자 자료형 = 매개변수 자료형
콜백 함수 자료형과 인자/매개변수(콜백함수를 전달인자로 다른함수에 전달될 때) 자료형이 동일

ⓑ
Call Back 함수 ➝(직관적 이해)➝ Call After 함수
**func\_cb\_2.c**

```cpp
콜백 함수(  )
{

}

function foo (매개변수 = 콜백 함수 주소값)
{
   콜백 함수 실행 코드 // 콜백 함수의 주소값을 사용하는 코드 포함
}


메인 함수
{

  foo (인자 = 콜백 함수 주소값);

}


```

🅐 02번째줄 콜백 함수에 해당하는 함수가 있고
🅑 16번째줄 함수 foo의 인자로 02번째줄 콜백 함수의 주소값을 전달 받아
🅒 07번째줄 함수 foo를 (02번째줄 콜백함수의 주소값을 매개변수로) 실행하면서
🅓 09번째줄 함수 foo의 콜백 함수 실행 코드 (02번째줄 콜백함수의 주소값을 사
용 하는 코드 내용 포함)를 실행
➝ Call After 함수: 직관적 명칭
∵ 16번째줄에 함수 foo가 호출/실행되고, 09번째줄에 콜백 함수가 실행
(02번째줄 콜백함수의 주소값을 사용 하는 코드 내용 포함)

ⓒ
C언어(순차적 작동) 콜백 함수(동시 작동) 사용 빈번도 下
C언어는 순차적으로 작동되는 운영 기반 (메인함수 실행중 사용자정의 함수 호출/실행하는 방식)
Ref)
Javascript는 동시에 작동하는 코드가 다수 (비동기 함수 사용)

## **Usability 유용성**
ⓐ Flexibility 유연성
ⓑ Modularity 모듈성 (Blockfication 블럭화)
ⓒ Reusability 재사용성

ⓐ Flexibility 유연성
프로그램 유연성 제공
프로그램 실행"중" 함수를 대체할 수 있음 (다른 콜백 함수 전달 ➝ 다른 동작 실행 O)

\[Counter\]
*   콜백 함수

콜백 함수 사용 의의 = (메인 함수 수정 X)

\= (다른 콜백 함수 전달 ➝ 다른 동작 실행 O)
*   사용자정의 함수

사용자정의 함수 사용 의의 = (메인 함수 수정 X)

\= (사용자정의 함수 수정 O ➝ 다른 동작 실행 O)

\[Conclusion\]
함수-콜백 함수/사용자정의 함수 실행 방식 (코드작성 법)의 차이
*   콜백 함수

메인 함수에서 인자에 해당하는 콜백함수 주소값(함수 포인터 변수)을 변경하는 코드 작성

i.e.) 콜백함수 주소값(함수 포인터 변수)에 해당하는 코드 작성 필요

*   사용자정의 함수

메인 함수에서 사용자정의 함수를 호출/실행하는 코드 작성

i.e.) 사용자정의 함수 코드 작성 필요

∴ 유연성 X

**func\_cb\_3.c**
사용자정의 함수 사용

```cpp
#include <stdio.h>

int get_bronze_price(int price)
{
	return price;
}

int get_silver_price(int price)
{
	return price * 0.9;               // discount 10%
}

int get_gold_price(int price)
{
	return price * 0.7;               // discount 30%
}

int main()
{
	int customer_grade;               // 0: bronze,  1: siver,  2: gold 입력 

	// set customer grade
	while (1)
	{
		printf("0: bronze,  1: silver,  2: gold\n");
		scanf("%d", &customer_grade);

		if (customer_grade == 0)
		{
			printf("customer_grade is bronze\n");
			break;
		}
		else if (customer_grade == 1)
		{
			printf("customer_grade is silver\n");
			break;
		}
		else if (customer_grade == 2)
		{
			printf("customer_grade is gold\n");
			break;
		}
		else
		{
			printf("wrong value\n");
		}
	}


	int total_price = 0;
	while (1)
	{
		int product_price = 0;

		printf("input product price(0: quit)\n");   
		scanf("%d", &product_price);                                                    // 제품 구매 가격     

		total_price = total_price + product_price;                                      // 누적 제품 구매 가격       

		if (product_price == 0)
			break;

		printf("product_price: %d\n", product_price);                                   // 제품 구매 가격     


		if (customer_grade == 0)
		{
			printf("discounted product price: %d\n", get_bronze_price(product_price));  // 할인 적용 후 단일 제품 구매 가격
			printf("pre-discounted total price: %d\n", total_price);                    // 할인 적용 전 누적 제품 구매 가격    
			printf("discounted total price: %d\n", get_bronze_price(total_price));      // 할인 적용 후 누적 제품 구매 가격
		}
		else if (customer_grade == 1)
		{
			printf("discounted product price: %d\n", get_silver_price(product_price));      
			printf("pre-discounted total price: %d\n", total_price);
			printf("discounted total price: %d\n", get_silver_price(total_price));
		}
		else if (customer_grade == 2)
		{
			printf("discounted product price: %d\n", get_gold_price(product_price));        
			printf("pre-dicounted total price: %d\n", total_price);
			printf("discounted total price: %d\n", get_gold_price(total_price));
		}
	}

	return 0;
}


```

**func\_cb\_4.c**
콜백 함수 사용

```cpp

#include <stdio.h>

int print_final_price(int price, int (*get_price_fp)(int))
{
    return get_price_fp(price);
}


int get_bronze_price(int price)
{
	return price;
}

int get_silver_price(int price)
{
	return price * 0.9;               // discount 10%
}

int get_gold_price(int price)
{
	return price * 0.7;               // discount 30%
}

int main()
{
	int customer_grade;               // 0: bronze,  1: siver,  2: gold 입력 
    int (*get_price_fp)(int);         // 함수 포인터변수 선언

	// set customer grade
    while (1)
    {
        printf("0: bronze,  1: silver,  2: gold\n");
        scanf("%d", &customer_grade);

        if (customer_grade == 0)
        {
            printf("customer_grade is bronze\n");
            get_price_fp = get_bronze_price;
            break;
        }
        else if (customer_grade == 1)
        {
            printf("customer_grade is silver\n");
            get_price_fp = get_silver_price;
            break;
        }
        else if (customer_grade == 2)
        {
            printf("customer_grade is gold\n");
            get_price_fp = get_gold_price;
            break;
        }
        else
        {
            printf("wrong value\n");
        }
    }

    int total_price = 0;

    while (1)
    {
        int product_price = 0;
        
        printf("input product price(0: quit)\n");
        scanf("%d", &product_price);                                                                  // 제품 구매 가격

        total_price = total_price + product_price;                                                    // 누적 제품 구매 가격    

        if (product_price == 0)
            break;
        
        printf("product_price: %d\n", product_price);                                                 // 제품 구매 가격
        // printf("discounted product price: %d\n", print_final_price);                                
        printf("discounted product price: %d\n", print_final_price(product_price, get_price_fp));     // 할인 적용 후 단일 제품 구매 가격

        printf("pre-discounted total price: %d\n", total_price);                                      // 할인 적용 전 누적 제품 구매 가격
        printf("discounted total price: %d\n", print_final_price(total_price, get_price_fp));         // 할인 적용 후 누적 제품 구매 가격

    }

    printf("pre-discounted total price: %d\n", total_price);                                          // 할인 적용 전 누적 제품 구매 가격
    printf("discounted total price: %d\n", print_final_price(total_price, get_price_fp));             // 할인 적용 후 누적 제품 구매 가격

    return 0;
}


```

∴ 함수-사용자정의 함수/콜백 함수 실행 방식 (코드작성 법)의 차이
∴ 유연성 X

ⓑ Modularity 모듈성 (Blockfication 블럭화)
특정기능(함수)을 모듈(블럭) 단위로 관리 가능
*   콜백 함수 = 함수 자체를 모듈화

🅐 모듈화된 함수 수정(e.g. 병합) ➝ 다른 함수 생성 가능 O

🅑 프로세스 모듈화 ➝ 프로그램 단위 모듈화 가능 O

≈ ⓒ Reusability 재사용성

*   사용자정의 함수 = 함수 호출을 모듈화

\[Counter\]
*   콜백 함수

콜백 함수 자체 = 모듈(블럭)

콜백 함수 호출 = 함수 주소값 호출 (함수 포인터 변수)

*   사용자정의 함수

사용자정의 함수 자체 = 모듈(블럭)

사용자정의 함수 호출 = 함수 주소값 호출 (함수 名 ≒ 함수 주소값)

i.e. 사용자정의 함수 = 함수 자체를 모듈화

\[Conclusion\]
함수-콜백 함수/사용자정의 함수 실행 방식 (코드작성 법)의 차이
∴ Modularity 모듈성 (Blockfication 블럭화) X

🅐 모듈화된 함수 수정(e.g. 병합) ➝ 다른 함수 생성 가능 O
**func\_cb\_5.c**
사용자정의 함수 사용

```cpp
#include <stdio.h>

void func1()
{
    printf("hello world\n");
}

void func2()
{
    printf("bye world\n");
}

int main()
{
    func1();  
    func2(); 
	
    return 0;
}


```

**func\_cb\_6.c**
콜백 함수 사용

```cpp
#include <stdio.h>

void fun1()
{
    printf("hello world\n");
}

void fun2()
{
    printf("bye world\n");
}

void integrate_fun(void (*function_A)(), void (*function_B)())  
{
    function_A();  // 22번째줄 호출: fun1   //  23번째줄 호출: fun2
    function_B();  // 22번째줄 호출: fun2   //  23번째줄 호출: fun1
}

int main()
{
    integrate_fun(fun1, fun2);  // 콜백(함수 포인터 변수 사용)
    integrate_fun(fun2, fun1);  // 콜백(함수 포인터 변수 사용)

    return 0;
}


```

모듈화된 함수 수정(e.g. 병합) ➝ 다른 함수 생성 가능 O
*   모듈화된 함수 = fun1, fun 2
*   다른 함수 = integrate\_fun
※ 협업시 함수 integrate\_fun 이 Pre-Architected ➝ 개발자 A, B가 fun1, fun2를 작성/전달

\[Counter\]
*   콜백 함수

함수 fun1, fun2의 본질적 병합 X

메인 함수내 함수 integrate\_fun 에서 함수 fun1, fun2를 각각 호출/실행

*   사용자정의 함수

함수 fun1, fun2의 본질적 병합 X

메인 함수내 함수 fun1, fun2 를 각각 호출/실행

\[Conclusion\]
함수-콜백 함수/사용자정의 함수 실행 방식 (코드작성 법)의 차이
∴ Modularity 모듈성 (Blockfication 블럭화) X

ⓒ Reusability 재사용성
🅐 프로그램내 여러 위치에서 동일 콜백 함수 사용

➝ 재사용

🅑 프로그램내 함수 1개(전달받는 함수 = 시스템)을 활용하여 여러 실행될 함수(= 콜백 함수) 사용

➝ 재사용

★ ⓒ Reusability 재사용성
⊃ ⓑ Modularity 모듈성 (Blockfication 블럭화)
⊃ ⓐ Flexibility 유연성

\[Counter\]
*   콜백 함수

🅐 여러 위치에서 동일 콜백 함수 사용 ➝ 재사용

🅑 여러 콜백 함수 작성 필요

※ 여러 콜백 함수를 전달받는 함수 1개 필요

※ 전달받는 함수 1개를 이용하여 여러 콜백 함수 호출/실행 작성 여러번 필요

*   사용자정의 함수

🅐 여러 위치에서 동일 사용자정의 함수 호출/실행 ➝ 재사용

🅑 여러 사용자정의 함수 작성 필요

※ 해당 사용자정의 함수 호출/실행 작성 여러번 필요

\[Re-Counter\]
*   콜백 함수

콜백함수를 전달받는 함수(e.g. function foo) 를 (콜백 함수를 매개변수로) 재사용 O

전달받는 함수 1개를 이용하여 여러 콜백 함수 호출/실행 작성이 개발자당 각각 1번 필요

*   사용자정의 함수

여러 사용자정의 함수 자체를 재사용 O

해당 사용자정의 함수 호출/실행 작성 여러번 필요

🅐 전달받는 함수를 여러번 사용하는 경우 발생
🅑 전달받는 함수
➝ Architecter 가 전달받는 함수를 시스템화/시스템구축
🅒 Architecter 가 만든 시스템 함수에 개발자 A, B, C 가 만든 콜백함수 a, b, c를 전달 실행
➝ Architecter 가 만든 시스템 함수

E.g #1)
*   시스템 함수 (전달받는 함수)

윈도우 부팅 함수

⒜ 전원 On

⒝ 디스플레이 On Default

⒞ 사운드 On Default

⒟ 상태화면 출력 (윈도우 기본 메인화면 출력 함수)

*   개발자 함수 (변경 함수)

디스플레이 On 카카오 (라이언 캐릭터 출력 함수)

시스템 함수 호출/실행에 인자로 디스플레이 온 카카오 함수 전달

| 시스템 함수 | 개발자 함수 |
| ---| --- |
| 시스템 함수 ( )<br>{<br>⒜ 전원 On<br>⒝ 디스플레이 On Default<br>⒞ 사운드 On Default<br>⒟ 상태화면 출력<br>}<br><br>메인 함수 ( )<br>{<br>시스템 함수 ( )<br>} | 디스플레이 온 카카오 ( )<br>{<br>⒝+ 라이언 출력<br>}<br><br><br><br><br>메인 함수 ( )<br>{<br>시스템 함수 (디스플레이 온 카카오)<br>} |
| E.g.)<br>( )<br>➝ (C++: int a = 100)<br>Default<br>매개변수 a에 값 전달 X ➝ a = 100 | E.g.)<br>(디스플레이 온 카카오)<br>➝ (C++: int a = 10)<br>Default<br>매개변수 a에 값 전달 X ➝ a = 10 |
| 방법 #1<br>( ) 매개변수 설정 세분화<br>시스템 함수 ⒝가 디스플레이 온 카카오 ⒝+로 대체 |
| 방법 #2<br>( ) 매개변수 설정 세분화<br>시스템 함수 수정 ➝ ⒝ 이벤트 발생후 ⒝+ 실행 |

*   콜백함수 재사용 = 시스템 재사용

시스템 (전달받는 함수)는 구축되어 있고, 콜백 함수를 여러 갯수 및 구축/변경하여 사용

*   사용자정의 함수 재사용 = 함수 재사용

E.g #2)
*   모바일 앱 화면은 여러개의 View Sections로 분할 구성

e.g. Backward, Open Image, Off-Button, etc.

*   각각의 View Sections은 사용자가 Touch할때 실행될 On-Touch 함수로 Pre-작성

시스템 Architector가 Non-Function(Blank-Function)의 Default On-Touch 함수 Pre-작성

🅐 View Section #1 - Default On-Touch #1 ➝ Corresponded to Function Backward

🅑 View Section #2 - Default On-Touch #2 ➝ Corresponded to Function Open Image

🅒 View Section #3 - Default On-Touch #3 ➝ Corresponded to Function Off-Button

*   각각의 개발자들은 View Sections을 Touch 했을때 실제 기능을 실행할 On-Touch 함수만 작성

Default On-Touch 함수에 콜백 함수로써 실제 기능 작성

🅐 View Section #1 - Default On-Touch #1 ➝ Add Function Backward

🅑 View Section #2 - Default On-Touch #2 ➝ Add Function Open Image

🅒 View Section #3 - Default On-Touch #3 ➝ Add Function Off-Button

*   사용자가 각각의 View Section을 Touch 할때, 콜백으로 해당 기능 실행

시스템 함수 호출/실행에 인자로 On-Touch Backward/Open Image/Off-Button 전달

| 시스템 함수 | 개발자 함수 #1, 2, 3 |
| ---| --- |
| 시스템 함수 ( )<br>{<br>⒜ Default On-Touch #1<br>⒝ Default On-Touch #2<br>⒞ Default On-Touch #3<br>}<br><br>메인 함수 ( )<br>{<br>시스템 함수 ( )<br>} | #1<br>Function Backward ( )<br>{<br>⒜+ Perform Function Backward<br>}<br><br>메인 함수 ( )<br>{<br>시스템 함수 (Function Backward)<br>} |
| #2<br>Open Image Function ( )<br>{<br>⒝+ Perform Open Image Function<br>}<br><br>메인 함수 ( )<br>{<br>시스템 함수 (Function Open Image)<br>} |
| #3<br>Off-Button Function ( )<br>{<br>⒞+ Perform Off-Button Function<br>}<br><br>메인 함수 ( )<br>{<br>시스템 함수 (Function Off-Button)<br>} |
| E.g.)<br>( )<br>➝ (C++" int a = 100)<br>Default<br>매개변수 a에 값 전달 X ➝ a = 100<br> | E.g.)<br>(Function Backward)<br>➝ (C++: int a = 10)<br>(Function Open Image)<br>➝ (C++: int a = 20)<br>(Function Off-Button)<br>➝ (C++: int a = 30) |
| 방법 #1 (해당 O)<br>( ) 매개변수 설정 세분화<br>시스템 함수 Default ⒜, ⒝, ⒞에 콜백함수 ⒜+, ⒝+, ⒞+로 Fill-InIn<br><br>※<br>시스템 함수가 구축된 프로그램의 메인 함수에서<br>시스템 함수 호출/실행 인자가<br>개발자 함수 #1, 2, 3의 주소값으로 Fill-In 될 수 있도록 Pre-구현 |
| 방법 #2 (해당 X)<br>( ) 매개변수 설정 세분화<br>시스템 함수 수정 ➝ Default ⒜, ⒝, ⒞ 이벤트 발생후 ⒜+, ⒝+, ⒞+ 실행 |

*   콜백함수 재사용 = 시스템 재사용

시스템 (전달받는 함수)는 구축되어 있고, 콜백 함수를 여러 갯수 및 구축/변경하여 사용

*   사용자정의 함수 재사용 = 함수 재사용

\[Conclusion\]
∴ ⓒ Reusability 재사용성 O
⊃ ⓑ Modularity 모듈성 (Blockfication 블럭화)
⊃ ⓐ Flexibility 유연성

**func\_cb\_7.c**
사용자정의 함수 사용

```cpp

#include <stdio.h>

//================ machine ================
void turn_on_machine()
{
    printf("1. turn on machine\n");
    // check init
    // check ready
    // ....
}

void prepare_machine()
{
    printf("\n2. prepare machine\n");
    // check machine clear
    // check temperature
    // check water
    // put ingredient
    // ....
}

void run_machine()
{
    printf("\n3. run machine\n");
    // put water
    // put ingredient
    // led flashing
    // make
    // wait 10 seconds
    // ....
}

void turn_off_machine()
{
    printf("\n4. turn off machine\n");
    // clean machine
    // clean ingredient box
    // turn off heater
    // led off
    // wait 10 seconds
    // ....
}

//================ coffee ================
void prepareCoffee(char* ingredient)
{
    printf("grind %s in coffee grinder\n", ingredient);
}

void makeCoffee()
{
    printf("brewing coffee....\n");
}

void packageCoffeecup()
{
    printf("drop cup\n");
    printf("dispense coffee\n");
}

void packageCoffeetumbler()
{
    printf("dispense coffee\n");
}

//================ smoothie ================
void prepareSmoothie(char* ingredient)
{
    printf("grind %s in blender\n", ingredient);
}

void makeSmoothie()
{
    printf("mix ice and fruit\n");
}

void packageSmoothie()
{
    printf("drop cup\n");
    printf("dispense smoothie\n");
}


int main()
{
    //================ coffee 제조 ================
    char* coffee_bean = "starbucks coffee bean";

    //  machine-on
    turn_on_machine();

    // 재료 준비
    prepare_machine();
    prepareCoffee(coffee_bean);

    // 음료 제조
    run_machine();
    makeCoffee();

    // 음료 포장
    packageCoffeecup();
    turn_off_machine();

    // //================ smoothie 제조 ================
    // char* smoothie_fruit = "strawberry";

    // // machine-on
    // turn_on_machine();

    // // 재료 준비
    // prepare_machine();
    // prepareSmoothie(smoothie_fruit);

    // // 음료 제조
    // run_machine();
    // makeSmoothie();

    // // 음료 포장
    // packageSmoothie();
    // turn_off_machine();

    return 0;
}


```

개발자 A, B 가 시스템 Code - Machine 을 이해 할때
*   개발자 A, B 가 시스템 Code - Machine 활용 가능
*   개발자 A Code - Coffee, 개발자 B Code - Smoothie 작성 가능

**func\_cb\_8.c**
콜백 함수 사용

```cpp

#include <stdio.h>

// system = machine + coffee/smoothie
// callback을 받는 함수
void makeDrink(void (*prepare_ingredient)(char* ingredient), void (*make)(), void (*package_drink)(), char* ingredient)
//           리턴타입   함수포인터변수명   함수포인터변수 매개변수 자료형        
{
    // machine-on
    turn_on_machine();

    // 재료 준비
    prepare_machine();
    prepare_ingredient(ingredient);   // Coffee/Smoothie 함수 전달  →  Coffee/Smoothie 함수 실행 

    // 음료 제조
    run_machine(make);                // Coffee/Smoothie 함수 전달  →  Coffee/Smoothie 함수 실행 

    // 음료 포장
    package_drink();                  // Coffee/Smoothie 함수 전달  →  Coffee/Smoothie 함수 실행 
    turn_off_machine();
}


void turn_on_machine()
{
    printf("1. turn on machine\n");
    // check init
    // check ready
    // ....
}

void prepare_machine()
{
    printf("\n2. prepare machine\n");
    // check machine clear
    // check temperature
    // check water
    // put ingredient
    // ....
}

void run_machine(void(*make)())
{
    printf("\n3. run machine\n");
    // put water
    // put ingredient
    // led flashing
    make();                
    // wait 10 seconds
    // ....
}

void turn_off_machine()
{
    printf("\n4. turn off machine\n");
    // clean machine
    // clean ingredient box
    // turn off heater
    // led off
    // wait 10 seconds
    // ....
}

//================coffee================
void prepareCoffee(char* ingredient)
{
    printf("grind %s in coffee grinder\n", ingredient);
}

void makeCoffee()
{
    printf("brewing coffee....\n");
}

void packageCoffee_cup()
{
    printf("drop cup\n");
    printf("dispense coffee\n");
}

void packageCoffee_tumbler()
{
    printf("dispense coffee\n");
}

// //================smoothie================
// void prepareSmoothie(char* ingredient)
// {
//     printf("grind %s in blender\n", ingredient);
// }

// void makeSmoothie()
// {
//     printf("mix ice and fruit\n");
// }

// void packageSmoothie()
// {
//     printf("drop cup\n");
//     printf("dispense smoothie\n");
// }


int main()
{
    // coffee
    char* coffee_bean = "starbucks coffee bean";
    makeDrink(prepareCoffee, makeCoffee, packageCoffee_cup, coffee_bean);   // System 호출 = 실행 (prepareCoffee, makeCoffee, packageCoffee_cup = 콜백함수)

    // // smoothie
    // char* smoothie_fruit = "strawberry";
    // makeDrink(prepareSmoothie, makeSmoothie, packageSmoothie, smoothie_fruit);

    return 0;
}


```

개발자 A, B 가 시스템 Code - Machine 을 이해 하지 않아도
*   개발자 A, B 가 시스템 Code - Machine 활용 가능
*   개발자 A Code - Coffee, 개발자 B Code - Smoothie 작성 가능

* * *

Function: Synchronous vs Asynchronous + Blocking vs Non-Blocking ([https://doc.clickup.com/d/h/8ca07k8-22/5cfed3da07fe658/8ca07k8-6758](https://doc.clickup.com/d/h/8ca07k8-22/5cfed3da07fe658/8ca07k8-6758))
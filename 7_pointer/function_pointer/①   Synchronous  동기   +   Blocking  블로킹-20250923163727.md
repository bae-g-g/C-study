# ①   Synchronous  동기   +   Blocking  블로킹

# **① Synchronous 동기 + Blocking 블로킹**

Read/Write (어플리케이션이 커널에 Read or Write 시스템콜 요청)
파일 1개를 Read or Write 실행 완료후 ➝ 다음 동작 실행
파일 1개를 Read or Write 실행 완료후 ➝ 다음 동작 실행
. 완료시 까지 어플리케이션이 멈춰 있음
. 커널이 제어권을 어플리케이션에 돌려줄때 까지 어플리케이션이 멈춰 있음
. 어플리케이션이 제어권을 가지고 있지않음

*   **Operation 동작**

E.g) Read

![](https://t9003081320.p.clickup-attachments.com/t9003081320/61b2009c-0ca1-4a72-b665-a03ac871d078/image.png)

ⓐ 어플리케이션에서 커널에 System Call

Read 실행 시작 = 어플리케이션에서 커널에 파일 읽기 완료 확인 요청

ⓑ 어플리케이션 Block (멈춰 있음 + 제어권 없음 )

어플리케이션에서 커널로 제어권 넘어옴

커널에서 Read 시작 + 제어권 있음

ⓓ 커넬에서 파일 읽기 완료

커널에 제어권이랑 상관 없음

제어권은 여전히 어플리케이션에 있음

ⓒ 커널에서 Read가 완료

데이터가 어플리케이션에 전달

커널에서 어플리케이션으로 제어권 넘어옴

어플리케이션 Unblock (멈춰 있지 않음 + 제어권 있음)

*   **Feature 특징**

가장 보편적 방식

System Call (어플리케이션에서 커널에 어떤 동작을 요청) 이 종료될때 까지

어플리케이션이 멈춰 있음 (어플리케이션이 제어권을 가지고 있지 않음)

\= 커널의 실행이 완료될때 까지 어플리케이션이 멈춰 있음

\= 커널이 제어권을 어플리케이션에 돌려줄때 까지 어플리케이션이 멈춰 있음
\= 어플리케이션이 제어권을 가지고 있지 않음

CPU 사용하지 않음 ➝ 효율적인 처리 방법
ⓐ 어플리케이션 A = 동기 + 블로킹 동작
ⓑ 어플리케이션 B = 동기 + 블로킹 동작 (다른 동작일 수 있음, e.g. 비동기 + 블로킹)
ⓐ + ⓑ = 컴퓨터 전체 동작 개념

어플리케이션 A의 System Call로 인해 CPU가 멈춰있을때(최소한으로 사용)

어플리케이션 B가 실행될수 있음

특정 어플리케이션 작동으로 CPU가 멈춰있을때

다른 어플리케이션 작동 가능

∴ 컴퓨터가 다른실행에 CPU를 사용할수 있어서 총 소모시간 단축 ➝ 효율적인 처리 방법

![](https://t9003081320.p.clickup-attachments.com/t9003081320/e9ede8a5-70f9-42fb-947e-9cce1ed01419/image.png)

#### **Example)**

**sb\_1.c**

**sb\_2.c**